'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var vueAmapUtil = require('@vuemap/vue-amap-util');
var editorComponent = require('../../../mixins/editor-component.js');

var script = vue.defineComponent({
  name: "ElAmapEllipse",
  mixins: [vueAmapUtil.registerMixin, editorComponent["default"]],
  props: {
    center: {
      type: Array,
      required: true
    },
    radius: {
      type: Array,
      required: true
    },
    bubble: {
      type: Boolean,
      default: false
    },
    cursor: {
      type: String
    },
    strokeColor: {
      type: String
    },
    strokeOpacity: {
      type: Number
    },
    strokeWeight: {
      type: Number
    },
    fillColor: {
      type: String
    },
    fillOpacity: {
      type: Number
    },
    draggable: {
      type: Boolean,
      default: false
    },
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator(value) {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    strokeDasharray: {
      type: Array
    }
  },
  emits: ["update:center", "update:radius"],
  data() {
    return {
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Ellipse(options);
      if (vueAmapUtil.isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (vueAmapUtil.isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (vueAmapUtil.isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.EllipseEditor"], () => {
            this.$amapComponent.editor = new AMap.EllipseEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("move", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      this.$emit("update:center", target.getCenter().toArray());
      this.$emit("update:radius", target.getRadius());
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (vueAmapUtil.isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (vueAmapUtil.isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (vueAmapUtil.isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __fillColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillColor: value });
      }
    },
    __fillOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillOpacity: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});

exports["default"] = script;
//# sourceMappingURL=Ellipse.vue_vue_type_script_lang.js.map
