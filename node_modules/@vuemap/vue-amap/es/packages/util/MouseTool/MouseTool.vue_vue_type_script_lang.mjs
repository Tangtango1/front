import { defineComponent } from 'vue';
import { registerMixin } from '@vuemap/vue-amap-util';

var script = defineComponent({
  name: "ElAmapMouseTool",
  mixins: [registerMixin],
  props: {
    type: {
      type: String,
      required: true,
      default: "marker",
      validator(value) {
        return ["marker", "circle", "rectangle", "polyline", "polygon", "measureArea", "rule", "rectZoomIn", "rectZoomOut"].includes(value);
      }
    },
    drawOptions: {
      type: Object,
      default: () => null
    },
    autoClear: {
      type: Boolean,
      default: true
    },
    showTooltip: {
      type: Boolean,
      default: true
    },
    tooltipTextMap: {
      type: Object,
      default: () => null
    },
    textOptions: {
      type: Object,
      default: () => null
    }
  },
  emits: ["draw"],
  data() {
    return {
      preMapCursor: "",
      tipTexts: {
        marker: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u70B9\u4F4D",
        circle: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u5706",
        rectangle: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62",
        polyline: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u6298\u7EBF\u7ED8\u5236",
        polygon: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u591A\u8FB9\u5F62\u7ED8\u5236",
        measureArea: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53CC\u51FB\u5730\u56FE\u5B8C\u6210\u7ED8\u5236\u5E76\u8BA1\u7B97\u9762\u79EF",
        rule: "\u5355\u51FB\u5730\u56FE\u9009\u62E9\u62D0\u70B9\uFF0C\u53F3\u51FB\u5730\u56FE\u5B8C\u6210\u7ED8\u5236\u5E76\u8BA1\u7B97\u8DDD\u79BB",
        rectZoomIn: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62\uFF0C\u677E\u5F00\u5DE6\u952E\u653E\u5927\u5730\u56FE",
        rectZoomOut: "\u6309\u4F4F\u9F20\u6807\u5DE6\u952E\u62D6\u62FD\u7ED8\u5236\u77E9\u5F62\uFF0C\u677E\u5F00\u5DE6\u952E\u653E\u5927\u5730\u56FE"
      }
    };
  },
  methods: {
    __initComponent() {
      return new Promise((resolve) => {
        AMap.plugin(["AMap.MouseTool"], () => {
          if (this.tooltipTextMap) {
            Object.assign(this.tipTexts, this.tooltipTextMap);
          }
          this.$amapComponent = new AMap.MouseTool(this.$parentComponent);
          this.createTooltip();
          this.__type();
          this.bindEvent();
          this.preMapCursor = this.$parentComponent.getDefaultCursor();
          this.$parentComponent.setDefaultCursor("crosshair");
          resolve();
        });
      });
    },
    __type() {
      const type = this.type;
      if (this.$amapComponent[type]) {
        const options = this.drawOptions || {};
        this.$amapComponent[type](options);
        this.setText(this.tipTexts[type]);
      }
    },
    createTooltip() {
      if (this.showTooltip) {
        const textOptions = this.textOptions || {};
        textOptions.anchor = "top-left";
        textOptions.clickable = false;
        textOptions.bubble = true;
        textOptions.offset = [10, 10];
        this.$text = new AMap.Text(textOptions);
        this.$parentComponent.add(this.$text);
        this.$parentComponent.on("mousemove", this.getMousePosition);
      }
    },
    getMousePosition(e) {
      const lnglat = e.lnglat;
      this.$text.setPosition([lnglat.lng, lnglat.lat]);
    },
    setText(content) {
      if (this.$text) {
        this.$text.setText(content);
      }
    },
    bindEvent() {
      this.$amapComponent.on("draw", (e) => {
        const type = this.type;
        let emitData;
        if (type === "marker") {
          emitData = e.obj.getPosition().toArray();
        } else if (type === "circle") {
          emitData = {
            center: e.obj.getCenter().toArray(),
            radius: e.obj.getRadius()
          };
        } else if (type === "rectangle") {
          const bounds = e.obj.getBounds();
          const southWest = bounds.getSouthWest();
          const northEast = bounds.getNorthEast();
          emitData = [southWest.toArray(), northEast.toArray()];
        } else if (type === "polyline") {
          const path = e.obj.getPath();
          emitData = path.map((v) => v.toArray());
        } else if (type === "polygon") {
          const path = e.obj.getPath();
          emitData = path.map((v) => v.toArray());
        } else if (type === "measureArea") {
          const path = e.obj.getPath().map((v) => v.toArray());
          emitData = AMap.GeometryUtil.ringArea(path);
        } else if (type === "rule") {
          const path = e.obj.getPath().map((v) => v.toArray());
          emitData = AMap.GeometryUtil.distanceOfLine(path);
        } else if (type === "rectZoomIn") {
          emitData = true;
        } else if (type === "rectZoomOut") {
          emitData = true;
        }
        this.$emit("draw", emitData, e.obj);
        if (this.autoClear) {
          this.$$clear();
          this.__type();
        }
      });
    },
    $$close(ifClear = true) {
      if (this.$amapComponent) {
        this.$amapComponent.close(ifClear);
      }
    },
    $$open() {
      this.__type();
    },
    $$clear() {
      this.$$close(true);
    },
    destroyComponent() {
      if (!this.parentInstance.isDestroy) {
        this.$amapComponent.close(true);
        this.$parentComponent.setDefaultCursor(this.preMapCursor);
        if (this.$text) {
          this.$parentComponent.off("mousemove", this.getMousePosition);
          this.$parentComponent.remove(this.$text);
          this.$text = null;
        }
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    }
  },
  render() {
    return null;
  }
});

export { script as default };
//# sourceMappingURL=MouseTool.vue_vue_type_script_lang.mjs.map
