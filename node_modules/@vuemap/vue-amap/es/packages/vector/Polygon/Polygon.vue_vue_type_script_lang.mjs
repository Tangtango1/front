import { defineComponent } from 'vue';
import { registerMixin, isMapInstance, isOverlayGroupInstance, isVectorLayerInstance, convertLnglat } from '@vuemap/vue-amap-util';
import editorMixin from '../../../mixins/editor-component.mjs';

var script = defineComponent({
  name: "ElAmapPolygon",
  mixins: [registerMixin, editorMixin],
  props: {
    path: {
      type: Array,
      required: true
    },
    bubble: {
      type: Boolean,
      default: false
    },
    cursor: {
      type: String
    },
    strokeColor: {
      type: String
    },
    strokeOpacity: {
      type: Number
    },
    strokeWeight: {
      type: Number
    },
    fillColor: {
      type: String
    },
    fillOpacity: {
      type: Number
    },
    draggable: {
      type: Boolean,
      default: false
    },
    extData: {
      type: Object,
      default: () => null
    },
    strokeStyle: {
      type: String,
      validator(value) {
        return ["solid", "dashed"].indexOf(value) !== -1;
      }
    },
    strokeDasharray: {
      type: Array
    }
  },
  emits: ["update:path"],
  data() {
    return {
      converters: {}
    };
  },
  methods: {
    __initComponent(options) {
      this.$amapComponent = new AMap.Polygon(options);
      if (isMapInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      } else if (isOverlayGroupInstance(this.$parentComponent)) {
        this.$parentComponent.addOverlay(this.$amapComponent);
      } else if (isVectorLayerInstance(this.$parentComponent)) {
        this.$parentComponent.add(this.$amapComponent);
      }
      this.bindModelEvents();
    },
    bindModelEvents() {
      this.$amapComponent.on("dragend", () => {
        this.emitModel(this.$amapComponent);
      });
      this.$amapComponent.on("touchend", () => {
        this.emitModel(this.$amapComponent);
      });
    },
    createEditor() {
      return new Promise((resolve) => {
        if (this.$amapComponent.editor) {
          resolve();
        } else {
          AMap.plugin(["AMap.PolygonEditor"], () => {
            this.$amapComponent.editor = new AMap.PolygonEditor(this.$parentComponent, this.$amapComponent, this.editOptions);
            this.setEditorEvents();
            this.bindEditorModelEvents();
            resolve();
          });
        }
      });
    },
    bindEditorModelEvents() {
      this.$amapComponent.editor.on("addnode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("adjust", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("removenode", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("add", (e) => {
        this.emitModel(e.target);
      });
      this.$amapComponent.editor.on("end", (e) => {
        this.emitModel(e.target);
      });
    },
    emitModel(target) {
      const paths = target.getPath();
      const pathArray = paths.map(convertLnglat);
      this.$emit("update:path", pathArray);
    },
    destroyComponent() {
      if (this.$amapComponent.editor) {
        if (!this.parentInstance.isDestroy) {
          this.$amapComponent.editor.close();
        }
        this.$amapComponent.editor = null;
      }
      if (!this.parentInstance.isDestroy) {
        if (isMapInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        } else if (isOverlayGroupInstance(this.$parentComponent)) {
          this.$parentComponent.removeOverlay(this.$amapComponent);
        } else if (isVectorLayerInstance(this.$parentComponent)) {
          this.$parentComponent.remove(this.$amapComponent);
        }
      }
      if (this.$amapComponent.destroy) {
        this.$amapComponent.destroy();
      }
      this.$amapComponent = null;
      this.$parentComponent = null;
    },
    __zIndex(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ zIndex: value });
      }
    },
    __strokeColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeColor: value });
      }
    },
    __strokeOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeOpacity: value });
      }
    },
    __strokeWeight(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeWeight: value });
      }
    },
    __fillColor(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillColor: value });
      }
    },
    __fillOpacity(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ fillOpacity: value });
      }
    },
    __strokeStyle(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeStyle: value });
      }
    },
    __strokeDasharray(value) {
      if (this.$amapComponent) {
        this.$amapComponent.setOptions({ strokeDasharray: value });
      }
    },
    __editable(flag) {
      this.createEditor().then(() => {
        flag === true ? this.$amapComponent.editor.open() : this.$amapComponent.editor.close();
      });
    }
  },
  render() {
    return null;
  }
});

export { script as default };
//# sourceMappingURL=Polygon.vue_vue_type_script_lang.mjs.map
