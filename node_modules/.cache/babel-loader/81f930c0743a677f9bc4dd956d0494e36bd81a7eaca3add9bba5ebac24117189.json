{"ast":null,"code":"import arrayMap from './_arrayMap.mjs';\nimport baseIntersection from './_baseIntersection.mjs';\nimport baseIteratee from './_baseIteratee.mjs';\nimport baseRest from './_baseRest.mjs';\nimport castArrayLikeObject from './_castArrayLikeObject.mjs';\nimport last from './last.mjs';\n\n/**\n * This method is like `_.intersection` except that it accepts `iteratee`\n * which is invoked for each element of each `arrays` to generate the criterion\n * by which they're compared. The order and references of result values are\n * determined by the first array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n * // => [2.1]\n *\n * // The `_.property` iteratee shorthand.\n * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }]\n */\nvar intersectionBy = baseRest(function (arrays) {\n  var iteratee = last(arrays),\n    mapped = arrayMap(arrays, castArrayLikeObject);\n  if (iteratee === last(mapped)) {\n    iteratee = undefined;\n  } else {\n    mapped.pop();\n  }\n  return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, baseIteratee(iteratee, 2)) : [];\n});\nexport { intersectionBy as default };","map":{"version":3,"names":["intersectionBy","baseRest","arrays","iteratee","last","mapped","arrayMap","castArrayLikeObject","undefined","pop","length","baseIntersection","baseIteratee"],"sources":["../../../../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/intersectionBy.js"],"sourcesContent":["import arrayMap from './_arrayMap.js';\nimport baseIntersection from './_baseIntersection.js';\nimport baseIteratee from './_baseIteratee.js';\nimport baseRest from './_baseRest.js';\nimport castArrayLikeObject from './_castArrayLikeObject.js';\nimport last from './last.js';\n\n/**\n * This method is like `_.intersection` except that it accepts `iteratee`\n * which is invoked for each element of each `arrays` to generate the criterion\n * by which they're compared. The order and references of result values are\n * determined by the first array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n * // => [2.1]\n *\n * // The `_.property` iteratee shorthand.\n * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }]\n */\nvar intersectionBy = baseRest(function(arrays) {\n  var iteratee = last(arrays),\n      mapped = arrayMap(arrays, castArrayLikeObject);\n\n  if (iteratee === last(mapped)) {\n    iteratee = undefined;\n  } else {\n    mapped.pop();\n  }\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped, baseIteratee(iteratee, 2))\n    : [];\n});\n\nexport default intersectionBy;\n"],"mappings":";;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACG,IAACA,cAAc,GAAGC,QAAQ,CAAC,UAASC,MAAM,EAAE;EAC7C,IAAIC,QAAQ,GAAGC,IAAI,CAACF,MAAM,CAAC;IACvBG,MAAM,GAAGC,QAAQ,CAACJ,MAAM,EAAEK,mBAAmB,CAAC;EAElD,IAAIJ,QAAQ,KAAKC,IAAI,CAACC,MAAM,CAAC,EAAE;IAC7BF,QAAQ,GAAGK,SAAS;EACxB,CAAG,MAAM;IACLH,MAAM,CAACI,GAAG,EAAE;EAChB;EACE,OAAQJ,MAAM,CAACK,MAAM,IAAIL,MAAM,CAAC,CAAC,CAAC,KAAKH,MAAM,CAAC,CAAC,CAAC,GAC5CS,gBAAgB,CAACN,MAAM,EAAEO,YAAY,CAACT,QAAQ,EAAE,CAAC,CAAC,CAAC,GACnD,EAAE;AACR,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}