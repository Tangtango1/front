{"ast":null,"code":"import baseWrapperValue from './_baseWrapperValue.mjs';\nimport getView from './_getView.mjs';\nimport isArray from './isArray.mjs';\n\n/** Used to indicate the type of lazy iteratees. */\nvar LAZY_FILTER_FLAG = 1,\n  LAZY_MAP_FLAG = 2;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Extracts the unwrapped value from its lazy wrapper.\n *\n * @private\n * @name value\n * @memberOf LazyWrapper\n * @returns {*} Returns the unwrapped value.\n */\nfunction lazyValue() {\n  var array = this.__wrapped__.value(),\n    dir = this.__dir__,\n    isArr = isArray(array),\n    isRight = dir < 0,\n    arrLength = isArr ? array.length : 0,\n    view = getView(0, arrLength, this.__views__),\n    start = view.start,\n    end = view.end,\n    length = end - start,\n    index = isRight ? end : start - 1,\n    iteratees = this.__iteratees__,\n    iterLength = iteratees.length,\n    resIndex = 0,\n    takeCount = nativeMin(length, this.__takeCount__);\n  if (!isArr || !isRight && arrLength == length && takeCount == length) {\n    return baseWrapperValue(array, this.__actions__);\n  }\n  var result = [];\n  outer: while (length-- && resIndex < takeCount) {\n    index += dir;\n    var iterIndex = -1,\n      value = array[index];\n    while (++iterIndex < iterLength) {\n      var data = iteratees[iterIndex],\n        iteratee = data.iteratee,\n        type = data.type,\n        computed = iteratee(value);\n      if (type == LAZY_MAP_FLAG) {\n        value = computed;\n      } else if (!computed) {\n        if (type == LAZY_FILTER_FLAG) {\n          continue outer;\n        } else {\n          break outer;\n        }\n      }\n    }\n    result[resIndex++] = value;\n  }\n  return result;\n}\nexport { lazyValue as default };","map":{"version":3,"names":["LAZY_FILTER_FLAG","LAZY_MAP_FLAG","nativeMin","Math","min","lazyValue","array","__wrapped__","value","dir","__dir__","isArr","isArray","isRight","arrLength","length","view","getView","__views__","start","end","index","iteratees","__iteratees__","iterLength","resIndex","takeCount","__takeCount__","baseWrapperValue","__actions__","result","outer","iterIndex","data","iteratee","type","computed"],"sources":["../../../../../../../../node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es/_lazyValue.js"],"sourcesContent":["import baseWrapperValue from './_baseWrapperValue.js';\nimport getView from './_getView.js';\nimport isArray from './isArray.js';\n\n/** Used to indicate the type of lazy iteratees. */\nvar LAZY_FILTER_FLAG = 1,\n    LAZY_MAP_FLAG = 2;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * Extracts the unwrapped value from its lazy wrapper.\n *\n * @private\n * @name value\n * @memberOf LazyWrapper\n * @returns {*} Returns the unwrapped value.\n */\nfunction lazyValue() {\n  var array = this.__wrapped__.value(),\n      dir = this.__dir__,\n      isArr = isArray(array),\n      isRight = dir < 0,\n      arrLength = isArr ? array.length : 0,\n      view = getView(0, arrLength, this.__views__),\n      start = view.start,\n      end = view.end,\n      length = end - start,\n      index = isRight ? end : (start - 1),\n      iteratees = this.__iteratees__,\n      iterLength = iteratees.length,\n      resIndex = 0,\n      takeCount = nativeMin(length, this.__takeCount__);\n\n  if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n    return baseWrapperValue(array, this.__actions__);\n  }\n  var result = [];\n\n  outer:\n  while (length-- && resIndex < takeCount) {\n    index += dir;\n\n    var iterIndex = -1,\n        value = array[index];\n\n    while (++iterIndex < iterLength) {\n      var data = iteratees[iterIndex],\n          iteratee = data.iteratee,\n          type = data.type,\n          computed = iteratee(value);\n\n      if (type == LAZY_MAP_FLAG) {\n        value = computed;\n      } else if (!computed) {\n        if (type == LAZY_FILTER_FLAG) {\n          continue outer;\n        } else {\n          break outer;\n        }\n      }\n    }\n    result[resIndex++] = value;\n  }\n  return result;\n}\n\nexport default lazyValue;\n"],"mappings":";;;;AAIA;AACA,IAAIA,gBAAgB,GAAG,CAAC;EACpBC,aAAa,GAAG,CAAC;;AAErB;AACA,IAAIC,SAAS,GAAGC,IAAI,CAACC,GAAG;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAAA,EAAG;EACnB,IAAIC,KAAK,GAAG,IAAI,CAACC,WAAW,CAACC,KAAK,EAAE;IAChCC,GAAG,GAAG,IAAI,CAACC,OAAO;IAClBC,KAAK,GAAGC,OAAO,CAACN,KAAK,CAAC;IACtBO,OAAO,GAAGJ,GAAG,GAAG,CAAC;IACjBK,SAAS,GAAGH,KAAK,GAAGL,KAAK,CAACS,MAAM,GAAG,CAAC;IACpCC,IAAI,GAAGC,OAAO,CAAC,CAAC,EAAEH,SAAS,EAAE,IAAI,CAACI,SAAS,CAAC;IAC5CC,KAAK,GAAGH,IAAI,CAACG,KAAK;IAClBC,GAAG,GAAGJ,IAAI,CAACI,GAAG;IACdL,MAAM,GAAGK,GAAG,GAAGD,KAAK;IACpBE,KAAK,GAAGR,OAAO,GAAGO,GAAG,GAAID,KAAK,GAAG,CAAE;IACnCG,SAAS,GAAG,IAAI,CAACC,aAAa;IAC9BC,UAAU,GAAGF,SAAS,CAACP,MAAM;IAC7BU,QAAQ,GAAG,CAAC;IACZC,SAAS,GAAGxB,SAAS,CAACa,MAAM,EAAE,IAAI,CAACY,aAAa,CAAC;EAErD,IAAI,CAAChB,KAAK,IAAK,CAACE,OAAO,IAAIC,SAAS,IAAIC,MAAM,IAAIW,SAAS,IAAIX,MAAO,EAAE;IACtE,OAAOa,gBAAgB,CAACtB,KAAK,EAAE,IAAI,CAACuB,WAAW,CAAC;EACpD;EACE,IAAIC,MAAM,GAAG,EAAE;EAEfC,KAAK,EACL,OAAOhB,MAAM,EAAE,IAAIU,QAAQ,GAAGC,SAAS,EAAE;IACvCL,KAAK,IAAIZ,GAAG;IAEZ,IAAIuB,SAAS,GAAG,CAAC,CAAC;MACdxB,KAAK,GAAGF,KAAK,CAACe,KAAK,CAAC;IAExB,OAAO,EAAEW,SAAS,GAAGR,UAAU,EAAE;MAC/B,IAAIS,IAAI,GAAGX,SAAS,CAACU,SAAS,CAAC;QAC3BE,QAAQ,GAAGD,IAAI,CAACC,QAAQ;QACxBC,IAAI,GAAGF,IAAI,CAACE,IAAI;QAChBC,QAAQ,GAAGF,QAAQ,CAAC1B,KAAK,CAAC;MAE9B,IAAI2B,IAAI,IAAIlC,aAAa,EAAE;QACzBO,KAAK,GAAG4B,QAAQ;MACxB,CAAO,MAAM,IAAI,CAACA,QAAQ,EAAE;QACpB,IAAID,IAAI,IAAInC,gBAAgB,EAAE;UAC5B,SAAS+B,KAAK;QACxB,CAAS,MAAM;UACL,MAAMA,KAAK;QACrB;MACA;IACA;IACID,MAAM,CAACL,QAAQ,EAAE,CAAC,GAAGjB,KAAK;EAC9B;EACE,OAAOsB,MAAM;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}