{"ast":null,"code":"class Y {\n  constructor() {\n    this._listeners = {};\n  }\n  on(t, e, r) {\n    this._listeners[t] ? this._listeners[t].push({\n      callback: e,\n      isOnce: r\n    }) : this._listeners[t] = [{\n      callback: e,\n      isOnce: r\n    }];\n  }\n  off(t, e) {\n    if (!e) throw new Error(\"\\u53D6\\u6D88\\u4E8B\\u4EF6\\u65F6\\u9700\\u8981\\u4F20\\u5165\\u539F\\u56DE\\u8C03\\u51FD\\u6570\");\n    const r = this._listeners[t];\n    if (r && r.length > 0) {\n      for (let i = 0; i < r.length; i++) if (r[i].callback === e) {\n        r.splice(i, 1);\n        break;\n      }\n    }\n  }\n  emit(t, ...e) {\n    const r = this._listeners[t];\n    if (r && r.length > 0) for (let n = 0; n < r.length; n++) {\n      const s = r[n];\n      s.callback.call(this, ...e), s.isOnce && (r.splice(n, 1), n--);\n    }\n    const i = this._listeners[\"*\"];\n    if (i && i.length > 0) for (let n = 0; n < i.length; n++) {\n      const s = i[n];\n      s.callback.call(this, t, ...e), s.isOnce && (i.splice(n, 1), n--);\n    }\n  }\n  trigger(t, ...e) {\n    this.emit(t, e);\n  }\n}\nfunction dt(o, t, e) {\n  e === void 0 && (e = {});\n  var r = {\n    type: \"Feature\"\n  };\n  return (e.id === 0 || e.id) && (r.id = e.id), e.bbox && (r.bbox = e.bbox), r.properties = t || {}, r.geometry = o, r;\n}\nfunction H(o, t, e) {\n  e === void 0 && (e = {});\n  for (var r = 0, i = o; r < i.length; r++) {\n    var n = i[r];\n    if (n.length < 4) throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n    for (var s = 0; s < n[n.length - 1].length; s++) if (n[n.length - 1][s] !== n[0][s]) throw new Error(\"First and last Position are not equivalent.\");\n  }\n  var a = {\n    type: \"Polygon\",\n    coordinates: o\n  };\n  return dt(a, t, e);\n}\nfunction Bt(o, t, e) {\n  e === void 0 && (e = {});\n  var r = {\n    type: \"MultiPolygon\",\n    coordinates: o\n  };\n  return dt(r, t, e);\n}\nfunction ft(o) {\n  return o.type === \"Feature\" ? o.geometry : o;\n} /**\n  * splaytree v3.1.1\n  * Fast Splay tree for Node and browser\n  *\n  * @author Alexander Milevski <info@w8r.name>\n  * @license MIT\n  * @preserve\n  */ /*! *****************************************************************************\n     Copyright (c) Microsoft Corporation. All rights reserved.\n     Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\n     this file except in compliance with the License. You may obtain a copy of the\n     License at http://www.apache.org/licenses/LICENSE-2.0\n     THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\n     WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\n     MERCHANTABLITY OR NON-INFRINGEMENT.\n     See the Apache Version 2.0 License for specific language governing permissions\n     and limitations under the License.\n     ***************************************************************************** */\nfunction $t(o, t) {\n  var e = {\n      label: 0,\n      sent: function () {\n        if (n[0] & 1) throw n[1];\n        return n[1];\n      },\n      trys: [],\n      ops: []\n    },\n    r,\n    i,\n    n,\n    s;\n  return s = {\n    next: a(0),\n    throw: a(1),\n    return: a(2)\n  }, typeof Symbol == \"function\" && (s[Symbol.iterator] = function () {\n    return this;\n  }), s;\n  function a(l) {\n    return function (h) {\n      return u([l, h]);\n    };\n  }\n  function u(l) {\n    if (r) throw new TypeError(\"Generator is already executing.\");\n    for (; e;) try {\n      if (r = 1, i && (n = l[0] & 2 ? i.return : l[0] ? i.throw || ((n = i.return) && n.call(i), 0) : i.next) && !(n = n.call(i, l[1])).done) return n;\n      switch (i = 0, n && (l = [l[0] & 2, n.value]), l[0]) {\n        case 0:\n        case 1:\n          n = l;\n          break;\n        case 4:\n          return e.label++, {\n            value: l[1],\n            done: !1\n          };\n        case 5:\n          e.label++, i = l[1], l = [0];\n          continue;\n        case 7:\n          l = e.ops.pop(), e.trys.pop();\n          continue;\n        default:\n          if (n = e.trys, !(n = n.length > 0 && n[n.length - 1]) && (l[0] === 6 || l[0] === 2)) {\n            e = 0;\n            continue;\n          }\n          if (l[0] === 3 && (!n || l[1] > n[0] && l[1] < n[3])) {\n            e.label = l[1];\n            break;\n          }\n          if (l[0] === 6 && e.label < n[1]) {\n            e.label = n[1], n = l;\n            break;\n          }\n          if (n && e.label < n[2]) {\n            e.label = n[2], e.ops.push(l);\n            break;\n          }\n          n[2] && e.ops.pop(), e.trys.pop();\n          continue;\n      }\n      l = t.call(o, e);\n    } catch (h) {\n      l = [6, h], i = 0;\n    } finally {\n      r = n = 0;\n    }\n    if (l[0] & 5) throw l[1];\n    return {\n      value: l[0] ? l[1] : void 0,\n      done: !0\n    };\n  }\n}\nvar A = function () {\n  function o(t, e) {\n    this.next = null, this.key = t, this.data = e, this.left = null, this.right = null;\n  }\n  return o;\n}();\nfunction zt(o, t) {\n  return o > t ? 1 : o < t ? -1 : 0;\n}\nfunction P(o, t, e) {\n  for (var r = new A(null, null), i = r, n = r;;) {\n    var s = e(o, t.key);\n    if (s < 0) {\n      if (t.left === null) break;\n      if (e(o, t.left.key) < 0) {\n        var a = t.left;\n        if (t.left = a.right, a.right = t, t = a, t.left === null) break;\n      }\n      n.left = t, n = t, t = t.left;\n    } else if (s > 0) {\n      if (t.right === null) break;\n      if (e(o, t.right.key) > 0) {\n        var a = t.right;\n        if (t.right = a.left, a.left = t, t = a, t.right === null) break;\n      }\n      i.right = t, i = t, t = t.right;\n    } else break;\n  }\n  return i.right = t.left, n.left = t.right, t.left = r.right, t.right = r.left, t;\n}\nfunction X(o, t, e, r) {\n  var i = new A(o, t);\n  if (e === null) return i.left = i.right = null, i;\n  e = P(o, e, r);\n  var n = r(o, e.key);\n  return n < 0 ? (i.left = e.left, i.right = e, e.left = null) : n >= 0 && (i.right = e.right, i.left = e, e.right = null), i;\n}\nfunction pt(o, t, e) {\n  var r = null,\n    i = null;\n  if (t) {\n    t = P(o, t, e);\n    var n = e(t.key, o);\n    n === 0 ? (r = t.left, i = t.right) : n < 0 ? (i = t.right, t.right = null, r = t) : (r = t.left, t.left = null, i = t);\n  }\n  return {\n    left: r,\n    right: i\n  };\n}\nfunction Gt(o, t, e) {\n  return t === null ? o : (o === null || (t = P(o.key, t, e), t.left = o), t);\n}\nfunction Q(o, t, e, r, i) {\n  if (o) {\n    r(\"\" + t + (e ? \"\\u2514\\u2500\\u2500 \" : \"\\u251C\\u2500\\u2500 \") + i(o) + `\n`);\n    var n = t + (e ? \"    \" : \"\\u2502   \");\n    o.left && Q(o.left, n, !1, r, i), o.right && Q(o.right, n, !0, r, i);\n  }\n}\nvar J = function () {\n  function o(t) {\n    t === void 0 && (t = zt), this._root = null, this._size = 0, this._comparator = t;\n  }\n  return o.prototype.insert = function (t, e) {\n    return this._size++, this._root = X(t, e, this._root, this._comparator);\n  }, o.prototype.add = function (t, e) {\n    var r = new A(t, e);\n    this._root === null && (r.left = r.right = null, this._size++, this._root = r);\n    var i = this._comparator,\n      n = P(t, this._root, i),\n      s = i(t, n.key);\n    return s === 0 ? this._root = n : (s < 0 ? (r.left = n.left, r.right = n, n.left = null) : s > 0 && (r.right = n.right, r.left = n, n.right = null), this._size++, this._root = r), this._root;\n  }, o.prototype.remove = function (t) {\n    this._root = this._remove(t, this._root, this._comparator);\n  }, o.prototype._remove = function (t, e, r) {\n    var i;\n    if (e === null) return null;\n    e = P(t, e, r);\n    var n = r(t, e.key);\n    return n === 0 ? (e.left === null ? i = e.right : (i = P(t, e.left, r), i.right = e.right), this._size--, i) : e;\n  }, o.prototype.pop = function () {\n    var t = this._root;\n    if (t) {\n      for (; t.left;) t = t.left;\n      return this._root = P(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), {\n        key: t.key,\n        data: t.data\n      };\n    }\n    return null;\n  }, o.prototype.findStatic = function (t) {\n    for (var e = this._root, r = this._comparator; e;) {\n      var i = r(t, e.key);\n      if (i === 0) return e;\n      i < 0 ? e = e.left : e = e.right;\n    }\n    return null;\n  }, o.prototype.find = function (t) {\n    return this._root && (this._root = P(t, this._root, this._comparator), this._comparator(t, this._root.key) !== 0) ? null : this._root;\n  }, o.prototype.contains = function (t) {\n    for (var e = this._root, r = this._comparator; e;) {\n      var i = r(t, e.key);\n      if (i === 0) return !0;\n      i < 0 ? e = e.left : e = e.right;\n    }\n    return !1;\n  }, o.prototype.forEach = function (t, e) {\n    for (var r = this._root, i = [], n = !1; !n;) r !== null ? (i.push(r), r = r.left) : i.length !== 0 ? (r = i.pop(), t.call(e, r), r = r.right) : n = !0;\n    return this;\n  }, o.prototype.range = function (t, e, r, i) {\n    for (var n = [], s = this._comparator, a = this._root, u; n.length !== 0 || a;) if (a) n.push(a), a = a.left;else {\n      if (a = n.pop(), u = s(a.key, e), u > 0) break;\n      if (s(a.key, t) >= 0 && r.call(i, a)) return this;\n      a = a.right;\n    }\n    return this;\n  }, o.prototype.keys = function () {\n    var t = [];\n    return this.forEach(function (e) {\n      var r = e.key;\n      return t.push(r);\n    }), t;\n  }, o.prototype.values = function () {\n    var t = [];\n    return this.forEach(function (e) {\n      var r = e.data;\n      return t.push(r);\n    }), t;\n  }, o.prototype.min = function () {\n    return this._root ? this.minNode(this._root).key : null;\n  }, o.prototype.max = function () {\n    return this._root ? this.maxNode(this._root).key : null;\n  }, o.prototype.minNode = function (t) {\n    if (t === void 0 && (t = this._root), t) for (; t.left;) t = t.left;\n    return t;\n  }, o.prototype.maxNode = function (t) {\n    if (t === void 0 && (t = this._root), t) for (; t.right;) t = t.right;\n    return t;\n  }, o.prototype.at = function (t) {\n    for (var e = this._root, r = !1, i = 0, n = []; !r;) if (e) n.push(e), e = e.left;else if (n.length > 0) {\n      if (e = n.pop(), i === t) return e;\n      i++, e = e.right;\n    } else r = !0;\n    return null;\n  }, o.prototype.next = function (t) {\n    var e = this._root,\n      r = null;\n    if (t.right) {\n      for (r = t.right; r.left;) r = r.left;\n      return r;\n    }\n    for (var i = this._comparator; e;) {\n      var n = i(t.key, e.key);\n      if (n === 0) break;\n      n < 0 ? (r = e, e = e.left) : e = e.right;\n    }\n    return r;\n  }, o.prototype.prev = function (t) {\n    var e = this._root,\n      r = null;\n    if (t.left !== null) {\n      for (r = t.left; r.right;) r = r.right;\n      return r;\n    }\n    for (var i = this._comparator; e;) {\n      var n = i(t.key, e.key);\n      if (n === 0) break;\n      n < 0 ? e = e.left : (r = e, e = e.right);\n    }\n    return r;\n  }, o.prototype.clear = function () {\n    return this._root = null, this._size = 0, this;\n  }, o.prototype.toList = function () {\n    return Vt(this._root);\n  }, o.prototype.load = function (t, e, r) {\n    e === void 0 && (e = []), r === void 0 && (r = !1);\n    var i = t.length,\n      n = this._comparator;\n    if (r && et(t, e, 0, i - 1, n), this._root === null) this._root = K(t, e, 0, i), this._size = i;else {\n      var s = qt(this.toList(), Zt(t, e), n);\n      i = this._size + i, this._root = tt({\n        head: s\n      }, 0, i);\n    }\n    return this;\n  }, o.prototype.isEmpty = function () {\n    return this._root === null;\n  }, Object.defineProperty(o.prototype, \"size\", {\n    get: function () {\n      return this._size;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), Object.defineProperty(o.prototype, \"root\", {\n    get: function () {\n      return this._root;\n    },\n    enumerable: !0,\n    configurable: !0\n  }), o.prototype.toString = function (t) {\n    t === void 0 && (t = function (r) {\n      return String(r.key);\n    });\n    var e = [];\n    return Q(this._root, \"\", !0, function (r) {\n      return e.push(r);\n    }, t), e.join(\"\");\n  }, o.prototype.update = function (t, e, r) {\n    var i = this._comparator,\n      n = pt(t, this._root, i),\n      s = n.left,\n      a = n.right;\n    i(t, e) < 0 ? a = X(e, r, a, i) : s = X(e, r, s, i), this._root = Gt(s, a, i);\n  }, o.prototype.split = function (t) {\n    return pt(t, this._root, this._comparator);\n  }, o.prototype[Symbol.iterator] = function () {\n    var t;\n    return $t(this, function (e) {\n      switch (e.label) {\n        case 0:\n          t = this.minNode(), e.label = 1;\n        case 1:\n          return t ? [4, t] : [3, 3];\n        case 2:\n          return e.sent(), t = this.next(t), [3, 1];\n        case 3:\n          return [2];\n      }\n    });\n  }, o;\n}();\nfunction K(o, t, e, r) {\n  var i = r - e;\n  if (i > 0) {\n    var n = e + Math.floor(i / 2),\n      s = o[n],\n      a = t[n],\n      u = new A(s, a);\n    return u.left = K(o, t, e, n), u.right = K(o, t, n + 1, r), u;\n  }\n  return null;\n}\nfunction Zt(o, t) {\n  for (var e = new A(null, null), r = e, i = 0; i < o.length; i++) r = r.next = new A(o[i], t[i]);\n  return r.next = null, e.next;\n}\nfunction Vt(o) {\n  for (var t = o, e = [], r = !1, i = new A(null, null), n = i; !r;) t ? (e.push(t), t = t.left) : e.length > 0 ? (t = n = n.next = e.pop(), t = t.right) : r = !0;\n  return n.next = null, i.next;\n}\nfunction tt(o, t, e) {\n  var r = e - t;\n  if (r > 0) {\n    var i = t + Math.floor(r / 2),\n      n = tt(o, t, i),\n      s = o.head;\n    return s.left = n, o.head = o.head.next, s.right = tt(o, i + 1, e), s;\n  }\n  return null;\n}\nfunction qt(o, t, e) {\n  for (var r = new A(null, null), i = r, n = o, s = t; n !== null && s !== null;) e(n.key, s.key) < 0 ? (i.next = n, n = n.next) : (i.next = s, s = s.next), i = i.next;\n  return n !== null ? i.next = n : s !== null && (i.next = s), r.next;\n}\nfunction et(o, t, e, r, i) {\n  if (!(e >= r)) {\n    for (var n = o[e + r >> 1], s = e - 1, a = r + 1;;) {\n      do s++; while (i(o[s], n) < 0);\n      do a--; while (i(o[a], n) > 0);\n      if (s >= a) break;\n      var u = o[s];\n      o[s] = o[a], o[a] = u, u = t[s], t[s] = t[a], t[a] = u;\n    }\n    et(o, t, e, a, i), et(o, t, a + 1, r, i);\n  }\n}\nfunction S(o, t) {\n  if (!(o instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction gt(o, t) {\n  for (var e = 0; e < t.length; e++) {\n    var r = t[e];\n    r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(o, r.key, r);\n  }\n}\nfunction b(o, t, e) {\n  return t && gt(o.prototype, t), e && gt(o, e), o;\n}\nvar z = function (t, e) {\n    return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y;\n  },\n  rt = function (t, e) {\n    if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null;\n    var r = t.ll.x < e.ll.x ? e.ll.x : t.ll.x,\n      i = t.ur.x < e.ur.x ? t.ur.x : e.ur.x,\n      n = t.ll.y < e.ll.y ? e.ll.y : t.ll.y,\n      s = t.ur.y < e.ur.y ? t.ur.y : e.ur.y;\n    return {\n      ll: {\n        x: r,\n        y: n\n      },\n      ur: {\n        x: i,\n        y: s\n      }\n    };\n  },\n  N = Number.EPSILON;\nN === void 0 && (N = Math.pow(2, -52));\nvar jt = N * N,\n  it = function (t, e) {\n    if (-N < t && t < N && -N < e && e < N) return 0;\n    var r = t - e;\n    return r * r < jt * t * e ? 0 : t < e ? -1 : 1;\n  },\n  Ut = function () {\n    function o() {\n      S(this, o), this.reset();\n    }\n    return b(o, [{\n      key: \"reset\",\n      value: function () {\n        this.xRounder = new yt(), this.yRounder = new yt();\n      }\n    }, {\n      key: \"round\",\n      value: function (e, r) {\n        return {\n          x: this.xRounder.round(e),\n          y: this.yRounder.round(r)\n        };\n      }\n    }]), o;\n  }(),\n  yt = function () {\n    function o() {\n      S(this, o), this.tree = new J(), this.round(0);\n    }\n    return b(o, [{\n      key: \"round\",\n      value: function (e) {\n        var r = this.tree.add(e),\n          i = this.tree.prev(r);\n        if (i !== null && it(r.key, i.key) === 0) return this.tree.remove(e), i.key;\n        var n = this.tree.next(r);\n        return n !== null && it(r.key, n.key) === 0 ? (this.tree.remove(e), n.key) : e;\n      }\n    }]), o;\n  }(),\n  G = new Ut(),\n  Z = function (t, e) {\n    return t.x * e.y - t.y * e.x;\n  },\n  vt = function (t, e) {\n    return t.x * e.x + t.y * e.y;\n  },\n  _t = function (t, e, r) {\n    var i = {\n        x: e.x - t.x,\n        y: e.y - t.y\n      },\n      n = {\n        x: r.x - t.x,\n        y: r.y - t.y\n      },\n      s = Z(i, n);\n    return it(s, 0);\n  },\n  V = function (t) {\n    return Math.sqrt(vt(t, t));\n  },\n  Wt = function (t, e, r) {\n    var i = {\n        x: e.x - t.x,\n        y: e.y - t.y\n      },\n      n = {\n        x: r.x - t.x,\n        y: r.y - t.y\n      };\n    return Z(n, i) / V(n) / V(i);\n  },\n  Yt = function (t, e, r) {\n    var i = {\n        x: e.x - t.x,\n        y: e.y - t.y\n      },\n      n = {\n        x: r.x - t.x,\n        y: r.y - t.y\n      };\n    return vt(n, i) / V(n) / V(i);\n  },\n  mt = function (t, e, r) {\n    return e.y === 0 ? null : {\n      x: t.x + e.x / e.y * (r - t.y),\n      y: r\n    };\n  },\n  xt = function (t, e, r) {\n    return e.x === 0 ? null : {\n      x: r,\n      y: t.y + e.y / e.x * (r - t.x)\n    };\n  },\n  Ht = function (t, e, r, i) {\n    if (e.x === 0) return xt(r, i, t.x);\n    if (i.x === 0) return xt(t, e, r.x);\n    if (e.y === 0) return mt(r, i, t.y);\n    if (i.y === 0) return mt(t, e, r.y);\n    var n = Z(e, i);\n    if (n == 0) return null;\n    var s = {\n        x: r.x - t.x,\n        y: r.y - t.y\n      },\n      a = Z(s, e) / n,\n      u = Z(s, i) / n,\n      l = t.x + u * e.x,\n      h = r.x + a * i.x,\n      c = t.y + u * e.y,\n      d = r.y + a * i.y,\n      f = (l + h) / 2,\n      g = (c + d) / 2;\n    return {\n      x: f,\n      y: g\n    };\n  },\n  I = function () {\n    b(o, null, [{\n      key: \"compare\",\n      value: function (e, r) {\n        var i = o.comparePoints(e.point, r.point);\n        return i !== 0 ? i : (e.point !== r.point && e.link(r), e.isLeft !== r.isLeft ? e.isLeft ? 1 : -1 : q.compare(e.segment, r.segment));\n      }\n    }, {\n      key: \"comparePoints\",\n      value: function (e, r) {\n        return e.x < r.x ? -1 : e.x > r.x ? 1 : e.y < r.y ? -1 : e.y > r.y ? 1 : 0;\n      }\n    }]);\n    function o(t, e) {\n      S(this, o), t.events === void 0 ? t.events = [this] : t.events.push(this), this.point = t, this.isLeft = e;\n    }\n    return b(o, [{\n      key: \"link\",\n      value: function (e) {\n        if (e.point === this.point) throw new Error(\"Tried to link already linked events\");\n        for (var r = e.point.events, i = 0, n = r.length; i < n; i++) {\n          var s = r[i];\n          this.point.events.push(s), s.point = this.point;\n        }\n        this.checkForConsuming();\n      }\n    }, {\n      key: \"checkForConsuming\",\n      value: function () {\n        for (var e = this.point.events.length, r = 0; r < e; r++) {\n          var i = this.point.events[r];\n          if (i.segment.consumedBy === void 0) for (var n = r + 1; n < e; n++) {\n            var s = this.point.events[n];\n            s.consumedBy === void 0 && i.otherSE.point.events === s.otherSE.point.events && i.segment.consume(s.segment);\n          }\n        }\n      }\n    }, {\n      key: \"getAvailableLinkedEvents\",\n      value: function () {\n        for (var e = [], r = 0, i = this.point.events.length; r < i; r++) {\n          var n = this.point.events[r];\n          n !== this && !n.segment.ringOut && n.segment.isInResult() && e.push(n);\n        }\n        return e;\n      }\n    }, {\n      key: \"getLeftmostComparator\",\n      value: function (e) {\n        var r = this,\n          i = new Map(),\n          n = function (a) {\n            var u = a.otherSE;\n            i.set(a, {\n              sine: Wt(r.point, e.point, u.point),\n              cosine: Yt(r.point, e.point, u.point)\n            });\n          };\n        return function (s, a) {\n          i.has(s) || n(s), i.has(a) || n(a);\n          var u = i.get(s),\n            l = u.sine,\n            h = u.cosine,\n            c = i.get(a),\n            d = c.sine,\n            f = c.cosine;\n          return l >= 0 && d >= 0 ? h < f ? 1 : h > f ? -1 : 0 : l < 0 && d < 0 ? h < f ? -1 : h > f ? 1 : 0 : d < l ? -1 : d > l ? 1 : 0;\n        };\n      }\n    }]), o;\n  }(),\n  Xt = 0,\n  q = function () {\n    b(o, null, [{\n      key: \"compare\",\n      value: function (e, r) {\n        var i = e.leftSE.point.x,\n          n = r.leftSE.point.x,\n          s = e.rightSE.point.x,\n          a = r.rightSE.point.x;\n        if (a < i) return 1;\n        if (s < n) return -1;\n        var u = e.leftSE.point.y,\n          l = r.leftSE.point.y,\n          h = e.rightSE.point.y,\n          c = r.rightSE.point.y;\n        if (i < n) {\n          if (l < u && l < h) return 1;\n          if (l > u && l > h) return -1;\n          var d = e.comparePoint(r.leftSE.point);\n          if (d < 0) return 1;\n          if (d > 0) return -1;\n          var f = r.comparePoint(e.rightSE.point);\n          return f !== 0 ? f : -1;\n        }\n        if (i > n) {\n          if (u < l && u < c) return -1;\n          if (u > l && u > c) return 1;\n          var g = r.comparePoint(e.leftSE.point);\n          if (g !== 0) return g;\n          var p = e.comparePoint(r.rightSE.point);\n          return p < 0 ? 1 : p > 0 ? -1 : 1;\n        }\n        if (u < l) return -1;\n        if (u > l) return 1;\n        if (s < a) {\n          var y = r.comparePoint(e.rightSE.point);\n          if (y !== 0) return y;\n        }\n        if (s > a) {\n          var m = e.comparePoint(r.rightSE.point);\n          if (m < 0) return 1;\n          if (m > 0) return -1;\n        }\n        if (s !== a) {\n          var x = h - u,\n            w = s - i,\n            _ = c - l,\n            k = a - n;\n          if (x > w && _ < k) return 1;\n          if (x < w && _ > k) return -1;\n        }\n        return s > a ? 1 : s < a || h < c ? -1 : h > c ? 1 : e.id < r.id ? -1 : e.id > r.id ? 1 : 0;\n      }\n    }]);\n    function o(t, e, r, i) {\n      S(this, o), this.id = ++Xt, this.leftSE = t, t.segment = this, t.otherSE = e, this.rightSE = e, e.segment = this, e.otherSE = t, this.rings = r, this.windings = i;\n    }\n    return b(o, [{\n      key: \"replaceRightSE\",\n      value: function (e) {\n        this.rightSE = e, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE;\n      }\n    }, {\n      key: \"bbox\",\n      value: function () {\n        var e = this.leftSE.point.y,\n          r = this.rightSE.point.y;\n        return {\n          ll: {\n            x: this.leftSE.point.x,\n            y: e < r ? e : r\n          },\n          ur: {\n            x: this.rightSE.point.x,\n            y: e > r ? e : r\n          }\n        };\n      }\n    }, {\n      key: \"vector\",\n      value: function () {\n        return {\n          x: this.rightSE.point.x - this.leftSE.point.x,\n          y: this.rightSE.point.y - this.leftSE.point.y\n        };\n      }\n    }, {\n      key: \"isAnEndpoint\",\n      value: function (e) {\n        return e.x === this.leftSE.point.x && e.y === this.leftSE.point.y || e.x === this.rightSE.point.x && e.y === this.rightSE.point.y;\n      }\n    }, {\n      key: \"comparePoint\",\n      value: function (e) {\n        if (this.isAnEndpoint(e)) return 0;\n        var r = this.leftSE.point,\n          i = this.rightSE.point,\n          n = this.vector();\n        if (r.x === i.x) return e.x === r.x ? 0 : e.x < r.x ? 1 : -1;\n        var s = (e.y - r.y) / n.y,\n          a = r.x + s * n.x;\n        if (e.x === a) return 0;\n        var u = (e.x - r.x) / n.x,\n          l = r.y + u * n.y;\n        return e.y === l ? 0 : e.y < l ? -1 : 1;\n      }\n    }, {\n      key: \"getIntersection\",\n      value: function (e) {\n        var r = this.bbox(),\n          i = e.bbox(),\n          n = rt(r, i);\n        if (n === null) return null;\n        var s = this.leftSE.point,\n          a = this.rightSE.point,\n          u = e.leftSE.point,\n          l = e.rightSE.point,\n          h = z(r, u) && this.comparePoint(u) === 0,\n          c = z(i, s) && e.comparePoint(s) === 0,\n          d = z(r, l) && this.comparePoint(l) === 0,\n          f = z(i, a) && e.comparePoint(a) === 0;\n        if (c && h) return f && !d ? a : !f && d ? l : null;\n        if (c) return d && s.x === l.x && s.y === l.y ? null : s;\n        if (h) return f && a.x === u.x && a.y === u.y ? null : u;\n        if (f && d) return null;\n        if (f) return a;\n        if (d) return l;\n        var g = Ht(s, this.vector(), u, e.vector());\n        return g === null || !z(n, g) ? null : G.round(g.x, g.y);\n      }\n    }, {\n      key: \"split\",\n      value: function (e) {\n        var r = [],\n          i = e.events !== void 0,\n          n = new I(e, !0),\n          s = new I(e, !1),\n          a = this.rightSE;\n        this.replaceRightSE(s), r.push(s), r.push(n);\n        var u = new o(n, a, this.rings.slice(), this.windings.slice());\n        return I.comparePoints(u.leftSE.point, u.rightSE.point) > 0 && u.swapEvents(), I.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), i && (n.checkForConsuming(), s.checkForConsuming()), r;\n      }\n    }, {\n      key: \"swapEvents\",\n      value: function () {\n        var e = this.rightSE;\n        this.rightSE = this.leftSE, this.leftSE = e, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1;\n        for (var r = 0, i = this.windings.length; r < i; r++) this.windings[r] *= -1;\n      }\n    }, {\n      key: \"consume\",\n      value: function (e) {\n        for (var r = this, i = e; r.consumedBy;) r = r.consumedBy;\n        for (; i.consumedBy;) i = i.consumedBy;\n        var n = o.compare(r, i);\n        if (n !== 0) {\n          if (n > 0) {\n            var s = r;\n            r = i, i = s;\n          }\n          if (r.prev === i) {\n            var a = r;\n            r = i, i = a;\n          }\n          for (var u = 0, l = i.rings.length; u < l; u++) {\n            var h = i.rings[u],\n              c = i.windings[u],\n              d = r.rings.indexOf(h);\n            d === -1 ? (r.rings.push(h), r.windings.push(c)) : r.windings[d] += c;\n          }\n          i.rings = null, i.windings = null, i.consumedBy = r, i.leftSE.consumedBy = r.leftSE, i.rightSE.consumedBy = r.rightSE;\n        }\n      }\n    }, {\n      key: \"prevInResult\",\n      value: function () {\n        return this._prevInResult !== void 0 ? this._prevInResult : (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null, this._prevInResult);\n      }\n    }, {\n      key: \"beforeState\",\n      value: function () {\n        if (this._beforeState !== void 0) return this._beforeState;\n        if (!this.prev) this._beforeState = {\n          rings: [],\n          windings: [],\n          multiPolys: []\n        };else {\n          var e = this.prev.consumedBy || this.prev;\n          this._beforeState = e.afterState();\n        }\n        return this._beforeState;\n      }\n    }, {\n      key: \"afterState\",\n      value: function () {\n        if (this._afterState !== void 0) return this._afterState;\n        var e = this.beforeState();\n        this._afterState = {\n          rings: e.rings.slice(0),\n          windings: e.windings.slice(0),\n          multiPolys: []\n        };\n        for (var r = this._afterState.rings, i = this._afterState.windings, n = this._afterState.multiPolys, s = 0, a = this.rings.length; s < a; s++) {\n          var u = this.rings[s],\n            l = this.windings[s],\n            h = r.indexOf(u);\n          h === -1 ? (r.push(u), i.push(l)) : i[h] += l;\n        }\n        for (var c = [], d = [], f = 0, g = r.length; f < g; f++) if (i[f] !== 0) {\n          var p = r[f],\n            y = p.poly;\n          if (d.indexOf(y) === -1) if (p.isExterior) c.push(y);else {\n            d.indexOf(y) === -1 && d.push(y);\n            var m = c.indexOf(p.poly);\n            m !== -1 && c.splice(m, 1);\n          }\n        }\n        for (var x = 0, w = c.length; x < w; x++) {\n          var _ = c[x].multiPoly;\n          n.indexOf(_) === -1 && n.push(_);\n        }\n        return this._afterState;\n      }\n    }, {\n      key: \"isInResult\",\n      value: function () {\n        if (this.consumedBy) return !1;\n        if (this._isInResult !== void 0) return this._isInResult;\n        var e = this.beforeState().multiPolys,\n          r = this.afterState().multiPolys;\n        switch (L.type) {\n          case \"union\":\n            {\n              var i = e.length === 0,\n                n = r.length === 0;\n              this._isInResult = i !== n;\n              break;\n            }\n          case \"intersection\":\n            {\n              var s, a;\n              e.length < r.length ? (s = e.length, a = r.length) : (s = r.length, a = e.length), this._isInResult = a === L.numMultiPolys && s < a;\n              break;\n            }\n          case \"xor\":\n            {\n              var u = Math.abs(e.length - r.length);\n              this._isInResult = u % 2 === 1;\n              break;\n            }\n          case \"difference\":\n            {\n              var l = function (c) {\n                return c.length === 1 && c[0].isSubject;\n              };\n              this._isInResult = l(e) !== l(r);\n              break;\n            }\n          default:\n            throw new Error(\"Unrecognized operation type found \".concat(L.type));\n        }\n        return this._isInResult;\n      }\n    }], [{\n      key: \"fromRing\",\n      value: function (e, r, i) {\n        var n,\n          s,\n          a,\n          u = I.comparePoints(e, r);\n        if (u < 0) n = e, s = r, a = 1;else if (u > 0) n = r, s = e, a = -1;else throw new Error(\"Tried to create degenerate segment at [\".concat(e.x, \", \").concat(e.y, \"]\"));\n        var l = new I(n, !0),\n          h = new I(s, !1);\n        return new o(l, h, [i], [a]);\n      }\n    }]), o;\n  }(),\n  bt = function () {\n    function o(t, e, r) {\n      if (S(this, o), !Array.isArray(t) || t.length === 0) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      if (this.poly = e, this.isExterior = r, this.segments = [], typeof t[0][0] != \"number\" || typeof t[0][1] != \"number\") throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      var i = G.round(t[0][0], t[0][1]);\n      this.bbox = {\n        ll: {\n          x: i.x,\n          y: i.y\n        },\n        ur: {\n          x: i.x,\n          y: i.y\n        }\n      };\n      for (var n = i, s = 1, a = t.length; s < a; s++) {\n        if (typeof t[s][0] != \"number\" || typeof t[s][1] != \"number\") throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n        var u = G.round(t[s][0], t[s][1]);\n        u.x === n.x && u.y === n.y || (this.segments.push(q.fromRing(n, u, this)), u.x < this.bbox.ll.x && (this.bbox.ll.x = u.x), u.y < this.bbox.ll.y && (this.bbox.ll.y = u.y), u.x > this.bbox.ur.x && (this.bbox.ur.x = u.x), u.y > this.bbox.ur.y && (this.bbox.ur.y = u.y), n = u);\n      }\n      (i.x !== n.x || i.y !== n.y) && this.segments.push(q.fromRing(n, i, this));\n    }\n    return b(o, [{\n      key: \"getSweepEvents\",\n      value: function () {\n        for (var e = [], r = 0, i = this.segments.length; r < i; r++) {\n          var n = this.segments[r];\n          e.push(n.leftSE), e.push(n.rightSE);\n        }\n        return e;\n      }\n    }]), o;\n  }(),\n  Qt = function () {\n    function o(t, e) {\n      if (S(this, o), !Array.isArray(t)) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      this.exteriorRing = new bt(t[0], this, !0), this.bbox = {\n        ll: {\n          x: this.exteriorRing.bbox.ll.x,\n          y: this.exteriorRing.bbox.ll.y\n        },\n        ur: {\n          x: this.exteriorRing.bbox.ur.x,\n          y: this.exteriorRing.bbox.ur.y\n        }\n      }, this.interiorRings = [];\n      for (var r = 1, i = t.length; r < i; r++) {\n        var n = new bt(t[r], this, !1);\n        n.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = n.bbox.ll.x), n.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = n.bbox.ll.y), n.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = n.bbox.ur.x), n.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = n.bbox.ur.y), this.interiorRings.push(n);\n      }\n      this.multiPoly = e;\n    }\n    return b(o, [{\n      key: \"getSweepEvents\",\n      value: function () {\n        for (var e = this.exteriorRing.getSweepEvents(), r = 0, i = this.interiorRings.length; r < i; r++) for (var n = this.interiorRings[r].getSweepEvents(), s = 0, a = n.length; s < a; s++) e.push(n[s]);\n        return e;\n      }\n    }]), o;\n  }(),\n  wt = function () {\n    function o(t, e) {\n      if (S(this, o), !Array.isArray(t)) throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      try {\n        typeof t[0][0][0] == \"number\" && (t = [t]);\n      } catch (s) {}\n      this.polys = [], this.bbox = {\n        ll: {\n          x: Number.POSITIVE_INFINITY,\n          y: Number.POSITIVE_INFINITY\n        },\n        ur: {\n          x: Number.NEGATIVE_INFINITY,\n          y: Number.NEGATIVE_INFINITY\n        }\n      };\n      for (var r = 0, i = t.length; r < i; r++) {\n        var n = new Qt(t[r], this);\n        n.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = n.bbox.ll.x), n.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = n.bbox.ll.y), n.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = n.bbox.ur.x), n.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = n.bbox.ur.y), this.polys.push(n);\n      }\n      this.isSubject = e;\n    }\n    return b(o, [{\n      key: \"getSweepEvents\",\n      value: function () {\n        for (var e = [], r = 0, i = this.polys.length; r < i; r++) for (var n = this.polys[r].getSweepEvents(), s = 0, a = n.length; s < a; s++) e.push(n[s]);\n        return e;\n      }\n    }]), o;\n  }(),\n  Jt = function () {\n    b(o, null, [{\n      key: \"factory\",\n      value: function (e) {\n        for (var r = [], i = 0, n = e.length; i < n; i++) {\n          var s = e[i];\n          if (!(!s.isInResult() || s.ringOut)) {\n            for (var a = null, u = s.leftSE, l = s.rightSE, h = [u], c = u.point, d = []; a = u, u = l, h.push(u), u.point !== c;) for (;;) {\n              var f = u.getAvailableLinkedEvents();\n              if (f.length === 0) {\n                var g = h[0].point,\n                  p = h[h.length - 1].point;\n                throw new Error(\"Unable to complete output ring starting at [\".concat(g.x, \",\") + \" \".concat(g.y, \"]. Last matching segment found ends at\") + \" [\".concat(p.x, \", \").concat(p.y, \"].\"));\n              }\n              if (f.length === 1) {\n                l = f[0].otherSE;\n                break;\n              }\n              for (var y = null, m = 0, x = d.length; m < x; m++) if (d[m].point === u.point) {\n                y = m;\n                break;\n              }\n              if (y !== null) {\n                var w = d.splice(y)[0],\n                  _ = h.splice(w.index);\n                _.unshift(_[0].otherSE), r.push(new o(_.reverse()));\n                continue;\n              }\n              d.push({\n                index: h.length,\n                point: u.point\n              });\n              var k = u.getLeftmostComparator(a);\n              l = f.sort(k)[0].otherSE;\n              break;\n            }\n            r.push(new o(h));\n          }\n        }\n        return r;\n      }\n    }]);\n    function o(t) {\n      S(this, o), this.events = t;\n      for (var e = 0, r = t.length; e < r; e++) t[e].segment.ringOut = this;\n      this.poly = null;\n    }\n    return b(o, [{\n      key: \"getGeom\",\n      value: function () {\n        for (var e = this.events[0].point, r = [e], i = 1, n = this.events.length - 1; i < n; i++) {\n          var s = this.events[i].point,\n            a = this.events[i + 1].point;\n          _t(s, e, a) !== 0 && (r.push(s), e = s);\n        }\n        if (r.length === 1) return null;\n        var u = r[0],\n          l = r[1];\n        _t(u, e, l) === 0 && r.shift(), r.push(r[0]);\n        for (var h = this.isExteriorRing() ? 1 : -1, c = this.isExteriorRing() ? 0 : r.length - 1, d = this.isExteriorRing() ? r.length : -1, f = [], g = c; g != d; g += h) f.push([r[g].x, r[g].y]);\n        return f;\n      }\n    }, {\n      key: \"isExteriorRing\",\n      value: function () {\n        if (this._isExteriorRing === void 0) {\n          var e = this.enclosingRing();\n          this._isExteriorRing = e ? !e.isExteriorRing() : !0;\n        }\n        return this._isExteriorRing;\n      }\n    }, {\n      key: \"enclosingRing\",\n      value: function () {\n        return this._enclosingRing === void 0 && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing;\n      }\n    }, {\n      key: \"_calcEnclosingRing\",\n      value: function () {\n        for (var e = this.events[0], r = 1, i = this.events.length; r < i; r++) {\n          var n = this.events[r];\n          I.compare(e, n) > 0 && (e = n);\n        }\n        for (var s = e.segment.prevInResult(), a = s ? s.prevInResult() : null;;) {\n          if (!s) return null;\n          if (!a) return s.ringOut;\n          if (a.ringOut !== s.ringOut) return a.ringOut.enclosingRing() !== s.ringOut ? s.ringOut : s.ringOut.enclosingRing();\n          s = a.prevInResult(), a = s ? s.prevInResult() : null;\n        }\n      }\n    }]), o;\n  }(),\n  St = function () {\n    function o(t) {\n      S(this, o), this.exteriorRing = t, t.poly = this, this.interiorRings = [];\n    }\n    return b(o, [{\n      key: \"addInterior\",\n      value: function (e) {\n        this.interiorRings.push(e), e.poly = this;\n      }\n    }, {\n      key: \"getGeom\",\n      value: function () {\n        var e = [this.exteriorRing.getGeom()];\n        if (e[0] === null) return null;\n        for (var r = 0, i = this.interiorRings.length; r < i; r++) {\n          var n = this.interiorRings[r].getGeom();\n          n !== null && e.push(n);\n        }\n        return e;\n      }\n    }]), o;\n  }(),\n  Kt = function () {\n    function o(t) {\n      S(this, o), this.rings = t, this.polys = this._composePolys(t);\n    }\n    return b(o, [{\n      key: \"getGeom\",\n      value: function () {\n        for (var e = [], r = 0, i = this.polys.length; r < i; r++) {\n          var n = this.polys[r].getGeom();\n          n !== null && e.push(n);\n        }\n        return e;\n      }\n    }, {\n      key: \"_composePolys\",\n      value: function (e) {\n        for (var r = [], i = 0, n = e.length; i < n; i++) {\n          var s = e[i];\n          if (!s.poly) if (s.isExteriorRing()) r.push(new St(s));else {\n            var a = s.enclosingRing();\n            a.poly || r.push(new St(a)), a.poly.addInterior(s);\n          }\n        }\n        return r;\n      }\n    }]), o;\n  }(),\n  te = function () {\n    function o(t) {\n      var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : q.compare;\n      S(this, o), this.queue = t, this.tree = new J(e), this.segments = [];\n    }\n    return b(o, [{\n      key: \"process\",\n      value: function (e) {\n        var r = e.segment,\n          i = [];\n        if (e.consumedBy) return e.isLeft ? this.queue.remove(e.otherSE) : this.tree.remove(r), i;\n        var n = e.isLeft ? this.tree.insert(r) : this.tree.find(r);\n        if (!n) throw new Error(\"Unable to find segment #\".concat(r.id, \" \") + \"[\".concat(r.leftSE.point.x, \", \").concat(r.leftSE.point.y, \"] -> \") + \"[\".concat(r.rightSE.point.x, \", \").concat(r.rightSE.point.y, \"] \") + \"in SweepLine tree. Please submit a bug report.\");\n        for (var s = n, a = n, u = void 0, l = void 0; u === void 0;) s = this.tree.prev(s), s === null ? u = null : s.key.consumedBy === void 0 && (u = s.key);\n        for (; l === void 0;) a = this.tree.next(a), a === null ? l = null : a.key.consumedBy === void 0 && (l = a.key);\n        if (e.isLeft) {\n          var h = null;\n          if (u) {\n            var c = u.getIntersection(r);\n            if (c !== null && (r.isAnEndpoint(c) || (h = c), !u.isAnEndpoint(c))) for (var d = this._splitSafely(u, c), f = 0, g = d.length; f < g; f++) i.push(d[f]);\n          }\n          var p = null;\n          if (l) {\n            var y = l.getIntersection(r);\n            if (y !== null && (r.isAnEndpoint(y) || (p = y), !l.isAnEndpoint(y))) for (var m = this._splitSafely(l, y), x = 0, w = m.length; x < w; x++) i.push(m[x]);\n          }\n          if (h !== null || p !== null) {\n            var _ = null;\n            if (h === null) _ = p;else if (p === null) _ = h;else {\n              var k = I.comparePoints(h, p);\n              _ = k <= 0 ? h : p;\n            }\n            this.queue.remove(r.rightSE), i.push(r.rightSE);\n            for (var D = r.split(_), M = 0, R = D.length; M < R; M++) i.push(D[M]);\n          }\n          i.length > 0 ? (this.tree.remove(r), i.push(e)) : (this.segments.push(r), r.prev = u);\n        } else {\n          if (u && l) {\n            var E = u.getIntersection(l);\n            if (E !== null) {\n              if (!u.isAnEndpoint(E)) for (var T = this._splitSafely(u, E), F = 0, U = T.length; F < U; F++) i.push(T[F]);\n              if (!l.isAnEndpoint(E)) for (var B = this._splitSafely(l, E), $ = 0, W = B.length; $ < W; $++) i.push(B[$]);\n            }\n          }\n          this.tree.remove(r);\n        }\n        return i;\n      }\n    }, {\n      key: \"_splitSafely\",\n      value: function (e, r) {\n        this.tree.remove(e);\n        var i = e.rightSE;\n        this.queue.remove(i);\n        var n = e.split(r);\n        return n.push(i), e.consumedBy === void 0 && this.tree.insert(e), n;\n      }\n    }]), o;\n  }(),\n  Et = typeof process != \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6,\n  ee = typeof process != \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6,\n  re = function () {\n    function o() {\n      S(this, o);\n    }\n    return b(o, [{\n      key: \"run\",\n      value: function (e, r, i) {\n        L.type = e, G.reset();\n        for (var n = [new wt(r, !0)], s = 0, a = i.length; s < a; s++) n.push(new wt(i[s], !1));\n        if (L.numMultiPolys = n.length, L.type === \"difference\") for (var u = n[0], l = 1; l < n.length;) rt(n[l].bbox, u.bbox) !== null ? l++ : n.splice(l, 1);\n        if (L.type === \"intersection\") {\n          for (var h = 0, c = n.length; h < c; h++) for (var d = n[h], f = h + 1, g = n.length; f < g; f++) if (rt(d.bbox, n[f].bbox) === null) return [];\n        }\n        for (var p = new J(I.compare), y = 0, m = n.length; y < m; y++) for (var x = n[y].getSweepEvents(), w = 0, _ = x.length; w < _; w++) if (p.insert(x[w]), p.size > Et) throw new Error(\"Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.\");\n        for (var k = new te(p), D = p.size, M = p.pop(); M;) {\n          var R = M.key;\n          if (p.size === D) {\n            var E = R.segment;\n            throw new Error(\"Unable to pop() \".concat(R.isLeft ? \"left\" : \"right\", \" SweepEvent \") + \"[\".concat(R.point.x, \", \").concat(R.point.y, \"] from segment #\").concat(E.id, \" \") + \"[\".concat(E.leftSE.point.x, \", \").concat(E.leftSE.point.y, \"] -> \") + \"[\".concat(E.rightSE.point.x, \", \").concat(E.rightSE.point.y, \"] from queue. \") + \"Please file a bug report.\");\n          }\n          if (p.size > Et) throw new Error(\"Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.\");\n          if (k.segments.length > ee) throw new Error(\"Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.\");\n          for (var T = k.process(R), F = 0, U = T.length; F < U; F++) {\n            var B = T[F];\n            B.consumedBy === void 0 && p.insert(B);\n          }\n          D = p.size, M = p.pop();\n        }\n        G.reset();\n        var $ = Jt.factory(k.segments),\n          W = new Kt($);\n        return W.getGeom();\n      }\n    }]), o;\n  }(),\n  L = new re(),\n  ie = function (t) {\n    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];\n    return L.run(\"union\", t, r);\n  },\n  ne = function (t) {\n    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];\n    return L.run(\"intersection\", t, r);\n  },\n  oe = function (t) {\n    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];\n    return L.run(\"xor\", t, r);\n  },\n  se = function (t) {\n    for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++) r[i - 1] = arguments[i];\n    return L.run(\"difference\", t, r);\n  },\n  ae = {\n    union: ie,\n    intersection: ne,\n    xor: oe,\n    difference: se\n  };\nfunction ue(o, t, e) {\n  e === void 0 && (e = {});\n  var r = ft(o),\n    i = ft(t),\n    n = ae.intersection(r.coordinates, i.coordinates);\n  return n.length === 0 ? null : n.length === 1 ? H(n[0], e.properties) : Bt(n, e.properties);\n}\nconst v = {\n  mergeArray(o, t) {\n    if (t.length < 5e4) o.push.apply(o, t);else for (let e = 0, r = t.length; e < r; e += 1) o.push(t[e]);\n  },\n  now: Date.now || function () {\n    return new Date().getTime();\n  },\n  bind(o, t) {\n    return o.bind ? o.bind(t) : function () {\n      return o.apply(t, arguments);\n    };\n  },\n  forEach(o, t, e) {\n    if (o.forEach) return o.forEach(t, e);\n    for (let r = 0, i = o.length; r < i; r++) t.call(e, o[r], r);\n  },\n  map(o, t, e) {\n    if (o.map) return o.map(t, e);\n    const r = [];\n    for (let i = 0, n = o.length; i < n; i++) r[i] = t.call(e, o[i], i);\n    return r;\n  },\n  merge(o, t) {\n    if (t.length < 5e4) Array.prototype.push.apply(o, t);else for (let e = 0, r = t.length; e < r; e += 1) o.push(t[e]);\n  },\n  arrayIndexOf(o, t, e) {\n    if (o.indexOf) return o.indexOf(t, e);\n    let r,\n      i = o,\n      n = i.length >>> 0;\n    if (n === 0) return -1;\n    const s = 0 | e;\n    if (s >= n) return -1;\n    for (r = Math.max(s >= 0 ? s : n - Math.abs(s), 0); r < n;) {\n      if (r in i && i[r] === t) return r;\n      r++;\n    }\n    return -1;\n  },\n  extend(o) {\n    return o || (o = {}), this.extendObjs(o, Array.prototype.slice.call(arguments, 1));\n  },\n  extendObjs(o, t) {\n    o || (o = {});\n    for (let e = 0, r = t.length; e < r; e++) {\n      const i = t[e];\n      if (i) for (const n in i) i.hasOwnProperty(n) && (o[n] = i[n]);\n    }\n    return o;\n  },\n  debounce(o, t, e) {\n    let r,\n      i,\n      n,\n      s,\n      a,\n      u = function () {\n        const l = v.now() - s;\n        l < t && l >= 0 ? r = setTimeout(u, t - l) : (r = null, e || (a = o.apply(n, i), r || (n = i = null)));\n      };\n    return function () {\n      n = this, i = arguments, s = v.now();\n      const l = e && !r;\n      return r || (r = setTimeout(u, t)), l && (a = o.apply(n, i), n = i = null), a;\n    };\n  },\n  throttle(o, t, e) {\n    let r,\n      i,\n      n,\n      s = null,\n      a = 0;\n    e || (e = {});\n    const u = function () {\n      a = e.leading === !1 ? 0 : v.now(), s = null, n = o.apply(r, i), s || (r = i = null);\n    };\n    return function () {\n      const l = v.now();\n      a || e.leading !== !1 || (a = l);\n      const h = t - (l - a);\n      return r = this, i = arguments, h <= 0 || h > t ? (s && (clearTimeout(s), s = null), a = l, n = o.apply(r, i), s || (r = i = null)) : s || e.trailing === !1 || (s = setTimeout(u, h)), n;\n    };\n  },\n  escapeHtml(o) {\n    const t = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      '\"': \"&quot;\",\n      \"'\": \"&#x27;\",\n      \"`\": \"&#x60;\"\n    };\n    return `${o}`.replace(/[&<>\"']/g, function (e) {\n      return t[e];\n    });\n  }\n};\nvar nt = {\n  BBRFLAG: {\n    I: 1,\n    S: 2\n  },\n  ADCODES: {\n    COUNTRY: 1e5\n  }\n};\nfunction le(o) {\n  return o;\n}\nfunction he(o) {\n  if (o == null) return le;\n  var t,\n    e,\n    r = o.scale[0],\n    i = o.scale[1],\n    n = o.translate[0],\n    s = o.translate[1];\n  return function (a, u) {\n    u || (t = e = 0);\n    var l = 2,\n      h = a.length,\n      c = new Array(h);\n    for (c[0] = (t += a[0]) * r + n, c[1] = (e += a[1]) * i + s; l < h;) c[l] = a[l], ++l;\n    return c;\n  };\n}\nfunction ce(o, t) {\n  for (var e, r = o.length, i = r - t; i < --r;) e = o[i], o[i++] = o[r], o[r] = e;\n}\nfunction de(o, t) {\n  return typeof t == \"string\" && (t = o.objects[t]), t.type === \"GeometryCollection\" ? {\n    type: \"FeatureCollection\",\n    features: t.geometries.map(function (e) {\n      return Lt(o, e);\n    })\n  } : Lt(o, t);\n}\nfunction Lt(o, t) {\n  var e = t.id,\n    r = t.bbox,\n    i = t.properties == null ? {} : t.properties,\n    n = fe(o, t);\n  return e == null && r == null ? {\n    type: \"Feature\",\n    properties: i,\n    geometry: n\n  } : r == null ? {\n    type: \"Feature\",\n    id: e,\n    properties: i,\n    geometry: n\n  } : {\n    type: \"Feature\",\n    id: e,\n    bbox: r,\n    properties: i,\n    geometry: n\n  };\n}\nfunction fe(o, t) {\n  var e = he(o.transform),\n    r = o.arcs;\n  function i(h, c) {\n    c.length && c.pop();\n    for (var d = r[h < 0 ? ~h : h], f = 0, g = d.length; f < g; ++f) c.push(e(d[f], f));\n    h < 0 && ce(c, g);\n  }\n  function n(h) {\n    return e(h);\n  }\n  function s(h) {\n    for (var c = [], d = 0, f = h.length; d < f; ++d) i(h[d], c);\n    return c.length < 2 && c.push(c[0]), c;\n  }\n  function a(h) {\n    for (var c = s(h); c.length < 4;) c.push(c[0]);\n    return c;\n  }\n  function u(h) {\n    return h.map(a);\n  }\n  function l(h) {\n    var c = h.type,\n      d;\n    switch (c) {\n      case \"GeometryCollection\":\n        return {\n          type: c,\n          geometries: h.geometries.map(l)\n        };\n      case \"Point\":\n        d = n(h.coordinates);\n        break;\n      case \"MultiPoint\":\n        d = h.coordinates.map(n);\n        break;\n      case \"LineString\":\n        d = s(h.arcs);\n        break;\n      case \"MultiLineString\":\n        d = h.arcs.map(s);\n        break;\n      case \"Polygon\":\n        d = u(h.arcs);\n        break;\n      case \"MultiPolygon\":\n        d = h.arcs.map(u);\n        break;\n      default:\n        return null;\n    }\n    return {\n      type: c,\n      coordinates: d\n    };\n  }\n  return l(t);\n}\nfunction pe(o, t) {\n  let e,\n    r,\n    i,\n    n,\n    s = o;\n  e = t[t.length - 2];\n  for (let a = 0, u = t.length - 1; a < u; a++) {\n    r = t[a];\n    const l = s;\n    s = [], i = l[l.length - 1];\n    for (let h = 0, c = l.length; h < c; h++) n = l[h], ot(n, e, r) ? (ot(i, e, r) || s.push(kt(e, r, i, n)), s.push(n)) : ot(i, e, r) && s.push(kt(e, r, i, n)), i = n;\n    e = r;\n  }\n  return s.length < 3 ? [] : (s.push(s[0]), s);\n}\nfunction ge(o, t, e) {\n  const r = (e[1] - t[1]) / (e[0] - t[0]) * (o[0] - t[0]) + t[1];\n  return Math.abs(r - o[1]) < 1e-6 && o[0] >= t[0] && o[0] <= e[0];\n}\nfunction ye(o, t) {\n  for (let e = 0, r = t.length; e < r - 1; e++) if (ge(o, t[e], t[e + 1])) return !0;\n  return !1;\n}\nfunction ve(o, t) {\n  let e = !1;\n  for (let r = o[0], i = o[1], n = 0, s = t.length, a = s - 1; n < s; a = n++) {\n    const u = t[n][0],\n      l = t[n][1],\n      h = t[a][0],\n      c = t[a][1];\n    l > i != c > i && r < (h - u) * (i - l) / (c - l) + u && (e = !e);\n  }\n  return e;\n}\nfunction _e(o, t, e) {\n  let r,\n    i = t[0],\n    n = t[1];\n  const s = e[0] - i,\n    a = e[1] - n,\n    u = s * s + a * a;\n  return u > 0 && (r = ((o[0] - i) * s + (o[1] - n) * a) / u, r > 1 ? (i = e[0], n = e[1]) : r > 0 && (i += s * r, n += a * r)), [i, n];\n}\nfunction me(o, t, e) {\n  const r = _e(o, t, e),\n    i = o[0] - r[0],\n    n = o[1] - r[1];\n  return i * i + n * n;\n}\nfunction xe(o, t) {\n  let e = Number.MAX_VALUE;\n  for (let r = 0, i = t.length; r < i - 1; r++) {\n    const n = me(o, t[r], t[r + 1]);\n    n < e && (e = n);\n  }\n  return e;\n}\nfunction ot(o, t, e) {\n  return (e[0] - t[0]) * (o[1] - t[1]) > (e[1] - t[1]) * (o[0] - t[0]);\n}\nfunction kt(o, t, e, r) {\n  const i = [o[0] - t[0], o[1] - t[1]],\n    n = [e[0] - r[0], e[1] - r[1]],\n    s = o[0] * t[1] - o[1] * t[0],\n    a = e[0] * r[1] - e[1] * r[0],\n    u = 1 / (i[0] * n[1] - i[1] * n[0]);\n  return [(s * n[0] - a * i[0]) * u, (s * n[1] - a * i[1]) * u];\n}\nvar j = {\n  sqClosestDistanceToPolygon: xe,\n  pointOnPolygon: ye,\n  pointInPolygon: ve,\n  polygonClip: pe\n};\nconst st = nt.BBRFLAG,\n  at = [];\nfunction be(o, t) {\n  const e = [];\n  for (let r = 0, i = o.length; r < i; r++) {\n    const n = o[r].split(\"-\");\n    let s = n[0],\n      a = n.length > 1 ? n[1] : s;\n    s = parseInt(s, t), a = parseInt(a, t);\n    for (let u = s; u <= a; u++) e.push(u);\n  }\n  return e;\n}\nfunction It(o, t, e) {\n  if (o[t]) throw new Error(`Alreay exists:  ${o[t]}`);\n  o[t] = e;\n}\nfunction we(o) {\n  return at[o] || (at[o] = [st.I, o]), at[o];\n}\nfunction Se(o, t, e) {\n  if (o) for (let r = o.split(\":\"), i = parseInt(r[0], t), n = be(r[1].split(\",\"), t), s = we(i), a = 0, u = n.length; a < u; a++) It(e, n[a], s);\n}\nfunction Ee(o, t, e) {\n  if (o) {\n    const r = [];\n    let i = o.split(\":\"),\n      n = parseInt(i[0], t);\n    const s = i[1].split(\";\");\n    for (let a = 0, u = s.length; a < u; a++) {\n      i = s[a].split(\",\");\n      const l = [parseInt(i[0], t), 0];\n      i.length > 1 && (l[1] = parseInt(i[1], t)), r.push(l);\n    }\n    It(e, n, [st.S, r]);\n  }\n}\nfunction At(o, t) {\n  if (!o) return null;\n  const e = o.split(\",\"),\n    r = [];\n  for (let i = 0, n = e.length; i < n; i++) {\n    if (parseInt(e[i], t) < 0) return null;\n    r.push(parseInt(e[i], t));\n  }\n  return r;\n}\nfunction Le(o, t) {\n  if (!o) return null;\n  const e = o.split(\";\"),\n    r = [];\n  for (let i = 0, n = e.length; i < n; i++) r.push(At(e[i], t));\n  return r;\n}\nfunction ke(o) {\n  let t, e;\n  const r = o.r,\n    i = [],\n    n = o.idx.i.split(\"|\");\n  for (o.idx.i = null, t = 0, e = n.length; t < e; t++) Se(n[t], r, i);\n  n.length = 0;\n  const s = o.idx.s.split(\"|\");\n  for (o.idx.s = null, t = 0, e = s.length; t < e; t++) Ee(s[t], r, i);\n  s.length = 0, o.idx = null, o.idxList = i, o.mxr && (o.maxRect = At(o.mxr, r), o.mxr = null), o.mxsr && (o.maxSubRect = Le(o.mxsr, r), o.mxsr = null);\n}\nfunction Ie(o, t, e) {\n  for (let r = o.geoData.sub.features, i = 0, n = e.length; i < n; i++) {\n    const s = e[i],\n      a = r[s[0]],\n      u = a.geometry.coordinates[s[1]][0],\n      l = j.polygonClip(u, t);\n    !l || l.length < 4 ? console.warn(`Cliped ring length werid: ${l}`) : s[2] = l;\n  }\n  return !0;\n}\nfunction Ae(o, t, e) {\n  const r = o.bbIndex,\n    i = r.s;\n  (t < 0 || e < 0 || e >= r.h || t >= r.w) && console.warn(\"Wrong x,y\", t, e, r);\n  const n = e * r.w + t,\n    s = r.idxList[n];\n  if (s[0] !== st.S) return !1;\n  const a = s[1];\n  if (a[0].length > 2) return !1;\n  const u = t * i + r.l,\n    l = e * i + r.t;\n  return Ie(o, [[u, l], [u + i, l], [u + i, l + i], [u, l + i], [u, l]], a), !0;\n}\nvar Pt = {\n  prepareGridFeatureClip: Ae,\n  buildIdxList: ke\n};\nclass C {\n  constructor(t, e, r, i) {\n    this.x = t, this.y = e, this.width = r, this.height = i;\n  }\n  static getBoundsItemToExpand() {\n    return new C(Number.MAX_VALUE, Number.MAX_VALUE, -1, -1);\n  }\n  static boundsIntersect(t, e) {\n    return t.x <= e.x + e.width && e.x <= t.x + t.width && t.y <= e.y + e.height && e.y <= t.y + t.height;\n  }\n  isEmpty() {\n    return this.width < 0;\n  }\n  expandByPoint(t, e) {\n    let r, i, n, s;\n    this.isEmpty() ? (r = n = t, i = s = e) : (r = this.x, i = this.y, n = this.x + this.width, s = this.y + this.height, t < r ? r = t : t > n && (n = t), e < i ? i = e : e > s && (s = e)), this.x = r, this.y = i, this.width = n - r, this.height = s - i;\n  }\n}\nfunction Pe(o) {\n  const t = {},\n    e = o.objects;\n  for (const r in e) t[r] = de(o, e[r]);\n  return t;\n}\nfunction Ne(o) {\n  for (let t = o.sub ? o.sub.features : [], e = o.parent.properties, r = (e.acroutes || []).concat([e.adcode]), i = 0, n = t.length; i < n; i++) t[i].properties.subFeatureIndex = i, t[i].properties.acroutes = r;\n}\nfunction Me(o) {\n  if (!o._isBuiled) {\n    Pt.buildIdxList(o.bbIndex), o.geoData = Pe(o.topo), o.geoData.sub && Ne(o.geoData);\n    const t = o.topo.bbox;\n    o.bounds = new C(t[0], t[1], t[2] - t[0], t[3] - t[1]), o.topo = null, o._isBuiled = !0;\n  }\n  return o;\n}\nvar Re = {\n  buildData: Me\n};\nconst ut = {},\n  O = Math.PI / 180,\n  Nt = 180 / Math.PI,\n  Fe = Math.PI / 4,\n  Mt = .5 / Math.PI;\nfunction lt(o) {\n  return ut[o] || (ut[o] = 256 * Math.pow(2, o)), ut[o];\n}\nfunction Oe(o) {\n  let t = o[1],\n    e = o[0] * O,\n    r = t * O;\n  return r = Math.log(Math.tan(Fe + r / 2)), [e, r];\n}\nfunction Ce(o, t) {\n  t = t || 1;\n  const e = Mt,\n    r = .5,\n    i = -e,\n    n = .5;\n  return [t * (e * o[0] + r), t * (i * o[1] + n)];\n}\nfunction De(o) {\n  const t = o[0] * Nt,\n    e = (2 * Math.atan(Math.exp(o[1])) - Math.PI / 2) * Nt;\n  return [parseFloat(t.toFixed(6)), parseFloat(e.toFixed(6))];\n}\nfunction Te(o, t) {\n  const e = Mt,\n    r = .5,\n    i = -e,\n    n = .5;\n  return [(o[0] / t - r) / e, (o[1] / t - n) / i];\n}\nfunction Rt(o, t, e) {\n  const r = Ce(Oe(o), t);\n  return e && (r[0] = Math.round(r[0]), r[1] = Math.round(r[1])), r;\n}\nfunction Be(o, t, e) {\n  return Rt(o, lt(t), e);\n}\nfunction $e(o, t) {\n  const e = lt(t),\n    r = Te(o, e);\n  return De(r);\n}\nfunction ze(o, t) {\n  const e = Math.cos,\n    r = o[1] * O,\n    i = o[0] * O,\n    n = t[1] * O,\n    s = t[0] * O,\n    a = n - r,\n    u = s - i,\n    l = (1 - e(a) + (1 - e(u)) * e(r) * e(n)) / 2;\n  return 12756274 * Math.asin(Math.sqrt(l));\n}\nvar ht = {\n  haversineDistance: ze,\n  getScale: lt,\n  lngLatToPointByScale: Rt,\n  pointToLngLat: $e,\n  lngLatToPoint: Be\n};\nclass ct {\n  constructor(t, e, r) {\n    this.adcode = t, this._data = e, this._sqScaleFactor = e.scale * e.scale, this._opts = Object.assign({\n      nearTolerance: 2\n    }, r), this.setNearTolerance(this._opts.nearTolerance);\n  }\n  static getPropsOfFeature(t) {\n    return t && t.properties ? t.properties : null;\n  }\n  static getAdcodeOfFeature(t) {\n    return t ? t.properties.adcode : null;\n  }\n  static doesFeatureHasChildren(t) {\n    return !!t && t.properties.childrenNum > 0;\n  }\n  setNearTolerance(t) {\n    this._opts.nearTolerance = t, this._sqNearTolerance = t * t;\n  }\n  getIdealZoom() {\n    return this._data.idealZoom;\n  }\n  _getEmptySubFeatureGroupItem(t) {\n    return {\n      subFeatureIndex: t,\n      subFeature: this.getSubFeatureByIndex(t),\n      pointsIndexes: [],\n      points: []\n    };\n  }\n  groupByPosition(t, e) {\n    let r,\n      i,\n      n = {},\n      s = null;\n    for (r = 0, i = t.length; r < i; r++) {\n      const u = this.getLocatedSubFeatureIndex(e.call(null, t[r], r));\n      n[u] || (n[u] = this._getEmptySubFeatureGroupItem(u)), n[u].pointsIndexes.push(r), n[u].points.push(t[r]), u < 0 && (s = n[u]);\n    }\n    const a = [];\n    if (this._data.geoData.sub) for (r = 0, i = this._data.geoData.sub.features.length; r < i; r++) a.push(n[r] || this._getEmptySubFeatureGroupItem(r));\n    return s && a.push(s), n = null, a;\n  }\n  getLocatedSubFeatureIndex(t) {\n    return this._getLocatedSubFeatureIndexByPixel(this.lngLatToPixel(t));\n  }\n  getSubFeatureByIndex(t) {\n    return t >= 0 ? this.getSubFeatures()[t] : null;\n  }\n  _getLocatedSubFeatureIndexByPixel(t) {\n    if (!this._data.geoData.sub) return -1;\n    const e = this._data,\n      r = e.bbIndex,\n      i = t[0] - r.l,\n      n = t[1] - r.t,\n      s = Math.floor(n / r.s),\n      a = Math.floor(i / r.s);\n    if (a < 0 || s < 0 || s >= r.h || a >= r.w) return -1;\n    const u = s * r.w + a,\n      l = r.idxList[u];\n    if (!l) return -1;\n    const h = nt.BBRFLAG;\n    switch (l[0]) {\n      case h.I:\n        return l[1];\n      case h.S:\n        return Pt.prepareGridFeatureClip(e, a, s), this._calcLocatedFeatureIndexOfSList(t, l[1]);\n      default:\n        throw new Error(`Unknown BBRFLAG: ${l[0]}`);\n    }\n  }\n  _calcNearestFeatureIndexOfSList(t, e) {\n    let r = [];\n    this._data.geoData.sub && (r = this._data.geoData.sub.features);\n    let i = {\n      sq: Number.MAX_VALUE,\n      idx: -1\n    };\n    for (let n = 0, s = e.length; n < s; n++) {\n      const a = e[n],\n        u = r[a[0]],\n        l = a[2] || u.geometry.coordinates[a[1]][0],\n        h = j.sqClosestDistanceToPolygon(t, l);\n      h < i.sq && (i.sq = h, i.idx = a[0]);\n    }\n    return i.sq / this._sqScaleFactor < this._sqNearTolerance ? i.idx : -1;\n  }\n  _calcLocatedFeatureIndexOfSList(t, e) {\n    for (let r = this._data.geoData.sub.features, i = 0, n = e.length; i < n; i++) {\n      const s = e[i],\n        a = r[s[0]],\n        u = s[2] || a.geometry.coordinates[s[1]][0];\n      if (j.pointInPolygon(t, u) || j.pointOnPolygon(t, u)) return s[0];\n    }\n    return this._calcNearestFeatureIndexOfSList(t, e);\n  }\n  pixelToLngLat(t, e) {\n    return ht.pointToLngLat([t, e], this._data.pz);\n  }\n  lngLatToPixel(t) {\n    t instanceof AMap.LngLat && (t = [t.getLng(), t.getLat()]);\n    const e = ht.lngLatToPoint(t, this._data.pz);\n    return [Math.round(e[0]), Math.round(e[1])];\n  }\n  _convertRingCoordsToLngLats(t) {\n    const e = [];\n    for (let r = 0, i = t.length; r < i; r++) e[r] = this.pixelToLngLat(t[r][0], t[r][1]);\n    return e;\n  }\n  _convertPolygonCoordsToLngLats(t) {\n    const e = [];\n    for (let r = 0, i = t.length; r < i; r++) e[r] = this._convertRingCoordsToLngLats(t[r]);\n    return e;\n  }\n  _convertMultiPolygonCoordsToLngLats(t) {\n    const e = [];\n    for (let r = 0, i = t.length; r < i; r++) e[r] = this._convertPolygonCoordsToLngLats(t[r]);\n    return e;\n  }\n  _convertCoordsToLngLats(t, e) {\n    switch (t) {\n      case \"MultiPolygon\":\n        return this._convertMultiPolygonCoordsToLngLats(e);\n      default:\n        throw new Error(`Unknown type ${t}`);\n    }\n  }\n  _createLngLatFeature(t, e) {\n    const r = Object.assign({}, t);\n    return e && Object.assign(r.properties, e), r.geometry = Object.assign({}, r.geometry), r.geometry.coordinates = this._convertCoordsToLngLats(r.geometry.type, r.geometry.coordinates), r;\n  }\n  getAdcode() {\n    return this.getProps(\"adcode\");\n  }\n  getName() {\n    return this.getProps(\"name\");\n  }\n  getChildrenNum() {\n    return this.getProps(\"childrenNum\");\n  }\n  getProps(t) {\n    const e = ct.getPropsOfFeature(this._data.geoData.parent);\n    return e ? t ? e[t] : e : null;\n  }\n  getParentFeature() {\n    const t = this._data.geoData;\n    return t.lngLatParent || (t.lngLatParent = this._createLngLatFeature(t.parent)), t.lngLatParent;\n  }\n  getParentFeatureInPixel() {\n    return this._data.geoData.parent;\n  }\n  getSubFeatures() {\n    const t = this._data.geoData;\n    if (!t.sub) return [];\n    if (!t.lngLatSubList) {\n      const e = [];\n      for (let r = t.sub.features, i = 0, n = r.length; i < n; i++) e[i] = this._createLngLatFeature(r[i]);\n      t.lngLatSubList = e;\n    }\n    return [].concat(t.lngLatSubList);\n  }\n  getSubFeaturesInPixel() {\n    return this._data.geoData.sub ? [].concat(this._data.geoData.sub.features) : [];\n  }\n  getBounds() {\n    const t = this._data;\n    if (!t.lngLatBounds) {\n      const e = this._data.bounds;\n      t.lngLatBounds = new AMap.Bounds(this.pixelToLngLat(e.x, e.y + e.height), this.pixelToLngLat(e.x + e.width, e.y));\n    }\n    return t.lngLatBounds;\n  }\n}\nclass Ge extends Y {\n  constructor(t) {\n    super(), this._opts = Object.assign({\n      distDataLoc: \"//webapi.amap.com/ui/1.1/ui/geo/DistrictExplorer/assets/d_v2\"\n    }, t), this._areaNodesForLocating = null, this._areaNodeCache = {}, this._opts.preload && this.loadMultiAreaNodes(this._opts.preload);\n  }\n  setAreaNodesForLocating(t) {\n    t ? Array.isArray(t) || (t = [t]) : t = [], this._areaNodesForLocating = t || [];\n  }\n  _loadJson(t, e) {\n    const r = this;\n    return fetch(t, {\n      headers: {\n        Accept: \"application/json\"\n      }\n    }).then(i => i.json()).then(i => {\n      e && e.call(r, null, i);\n    }).catch(i => {\n      if (!e) throw i;\n      e(i);\n    });\n  }\n  _getAreaNodeDataFileName(t) {\n    return `an_${t}.json`;\n  }\n  _getAreaNodeDataSrc(t) {\n    return `${this._opts.distDataLoc}/${this._getAreaNodeDataFileName(t)}`;\n  }\n  loadAreaTree(t) {\n    this._loadJson(`${this._opts.distDataLoc}/area_tree.json`, t);\n  }\n  loadCountryNode(t) {\n    this.loadAreaNode(nt.ADCODES.COUNTRY, t);\n  }\n  loadMultiAreaNodes(t, e) {\n    let r = [],\n      i = !1,\n      n;\n    function s(a) {\n      return function (u, l) {\n        i || (n--, u ? (e && e(u), i = !0) : (r[a] = l, n === 0 && e && e(null, r)));\n      };\n    }\n    if (t && t.length) {\n      const a = t.length;\n      for (let u = 0; u < a; u++) this.loadAreaNode(t[u], e ? s(u) : null);\n    } else e && e(null, []);\n  }\n  loadAreaNode(t, e, r, i) {\n    if (r = r || this, this._areaNodeCache[t]) {\n      if (e) {\n        const n = this._areaNodeCache[t];\n        i ? e.call(r, null, n, !0) : setTimeout(function () {\n          e.call(r, null, n);\n        }, 0);\n      }\n    } else this._loadJson(this._getAreaNodeDataSrc(t), (n, s) => {\n      n ? e && e.call(r, n) : (this._buildAreaNode(t, s), e && e.call(r, null, this._areaNodeCache[t]));\n    });\n  }\n  getLocalAreaNode(t) {\n    return this._areaNodeCache[t] || null;\n  }\n  _buildAreaNode(t, e) {\n    if (!this._areaNodeCache[t]) {\n      if (!e) throw new Error(`Empty distData: ${t}`);\n      const r = new ct(t, Re.buildData(e), this._opts);\n      this._areaNodeCache[t] = r, this._areaNodesForLocating || (this._areaNodesForLocating = [r]);\n    }\n  }\n  clearAreaNodeCacheByAdcode(t) {\n    const e = this._areaNodeCache;\n    return delete e[t], !0;\n  }\n  destroy() {\n    this._areaNodesForLocating = null, this._areaNodeCache = null, this._opts = null;\n  }\n}\nclass Ze {\n  constructor(t) {\n    this.isDistReady = !1, this.nodeMap = {}, this.waitFnList = [], this.singleDistExplorer = new Ge({}), this._opts = v.extend({\n      topAdcodes: [1e5]\n    }, t), this._touchMap = {}, this.singleDistExplorer.loadAreaTree((e, r) => {\n      if (e) throw e;\n      if (this.filterAreaTree(r), this.singleCountryNode = r, this.isDistReady = !0, this.waitFnList.length) {\n        for (let i = 0, n = this.waitFnList.length; i < n; i++) this.waitFnList[i][0].call(this.waitFnList[i][1]);\n        this.waitFnList.length = 0;\n      }\n      this.singleDistExplorer.loadMultiAreaNodes(this._opts.topAdcodes);\n    });\n  }\n  pixelToLngLat(t, e, r) {\n    return ht.pointToLngLat([t, e], r);\n  }\n  getBounds(t) {\n    const e = t.bbounds;\n    return new AMap.Bounds(this.pixelToLngLat(e.x, e.y + e.height, 20), this.pixelToLngLat(e.x + e.width, e.y, 20));\n  }\n  filterAreaTree(t) {\n    const e = [t];\n    do {\n      const r = e.pop();\n      this.nodeMap[r.adcode] = r;\n      const i = r.bbox;\n      if (r.bbounds = new C(i[0], i[1], i[2], i[3]), r.bbox = this.getBounds(r), r.children) for (let n = r.children, s = 0, a = n.length; s < a; s++) n[s].childIdx = s, e.push(n[s]);\n    } while (e.length);\n  }\n  isReady() {\n    return this.isDistReady;\n  }\n  getParentAdcode(t, e) {\n    if (!e) {\n      const r = this.getNodeByAdcode(t);\n      if (!r) return console.warn(`Can not find node: ${t}`), null;\n      e = r.acroutes;\n    }\n    return e && e.length ? e[e.length - 1] : null;\n  }\n  getSubIdx(t) {\n    return this.getNodeByAdcode(t).childIdx;\n  }\n  getChildrenNum(t) {\n    const e = this.getNodeByAdcode(t);\n    return this.getChildrenNumOfNode(e);\n  }\n  getChildrenNumOfNode(t) {\n    return t.children ? t.children.length : t.childrenNum || 0;\n  }\n  getNodeByAdcode(t) {\n    const e = this.nodeMap[t];\n    if (!e) {\n      let r = this.singleDistExplorer.getLocalAreaNode(`${`${t}`.substr(0, 4)}00`);\n      if (r || (r = this.singleDistExplorer.getLocalAreaNode(`${`${t}`.substr(0, 2)}0000`)), !r) return null;\n      for (let i = r.getSubFeatures(), n = 0, s = i.length; n < s; n++) if (i[n].properties.adcode === t) return i[n].properties;\n    }\n    return e;\n  }\n  getNodeChildren(t) {\n    const e = this.getNodeByAdcode(t);\n    if (!e) return null;\n    if (e.children) return e.children;\n    if (e.childrenNum >= 0) {\n      const r = this.singleDistExplorer.getLocalAreaNode(t);\n      if (!r) return null;\n      const i = [],\n        n = r.getSubFeaturesInPixel();\n      for (let s = 0, a = n.length; s < a; s++) i.push(n[s].properties);\n      return i;\n    }\n    return null;\n  }\n  getExplorer() {\n    return this.singleDistExplorer;\n  }\n  traverseCountry(t, e, r, i, n) {\n    this.traverseNode(this.singleCountryNode, t, e, r, i, n, []);\n  }\n  getNodeBoundsSize(t, e) {\n    const r = this.getPixelZoom(),\n      i = Math.pow(2, r - e);\n    return [t.bbounds.width / i, t.bbounds.height / i];\n  }\n  doesRingRingIntersect(t, e) {\n    const r = [t.getNorthWest().toArray(), t.getNorthEast().toArray(), t.getSouthEast().toArray(), t.getSouthWest().toArray(), t.getNorthWest().toArray()],\n      i = [e.getNorthWest().toArray(), e.getNorthEast().toArray(), e.getSouthEast().toArray(), e.getSouthWest().toArray(), e.getNorthWest().toArray()];\n    return !!ue(H([r]), H([i]));\n  }\n  traverseNode(t, e, r, i, n, s, a, u) {\n    if (!(a && a.indexOf(t.adcode) >= 0)) {\n      if (this.doesRingRingIntersect(e, t.bbox)) {\n        const l = t.children,\n          h = l && l.length > 0;\n        if (r > t.idealZoom && h) for (let c = 0, d = l.length; c < d; c++) this.traverseNode(l[c], e, r, i, null, s, a);else i.call(s, t);\n      }\n      n && (u ? (u.count++, u.count >= u.total && n.call(s)) : n.call(s));\n    }\n  }\n  onReady(t, e, r) {\n    this.isDistReady ? r ? t.call(e) : setTimeout(function () {\n      t.call(e);\n    }, 0) : this.waitFnList.push([t, e]);\n  }\n  getPixelZoom() {\n    var t;\n    return (t = this.singleCountryNode) === null || t === void 0 ? void 0 : t.pz;\n  }\n  loadAreaNode(t, e, r, i) {\n    this.singleDistExplorer.loadAreaNode(t, e, r, i);\n  }\n  isExcludedAdcode(t) {\n    const e = this._opts.excludedAdcodes;\n    return e && e.indexOf(t) >= 0;\n  }\n  traverseTopNodes(t, e, r, i, n) {\n    const s = this._opts.topAdcodes,\n      a = this._opts.excludedAdcodes,\n      u = {\n        total: s.length,\n        count: 0\n      };\n    for (let l = 0, h = s.length; l < h; l++) {\n      const c = this.getNodeByAdcode(s[l]);\n      if (!c) throw new Error(`Can not find adcode: ${s[l]}`);\n      this.traverseNode(c, t, e, r, i, n, a, u);\n    }\n  }\n  tryClearCache(t, e) {\n    if (!(e < 0)) {\n      const r = [this.singleCountryNode],\n        i = [],\n        n = this._touchMap;\n      do {\n        const a = r.pop();\n        a.children && v.mergeArray(r, a.children);\n        const u = n[a.adcode];\n        u && u !== t && i.push(a.adcode);\n      } while (r.length);\n      i.sort(function (a, u) {\n        const l = n[a] - n[u];\n        return l === 0 ? a - u : l;\n      });\n      const s = i.length - e;\n      if (!(s <= 0)) for (let a = 0; a < s; a++) this.singleDistExplorer.clearAreaNodeCacheByAdcode(i[a]) && this.touchAdcode(i[a], null);\n    }\n  }\n  touchAdcode(t, e) {\n    this._touchMap[t] = e;\n  }\n  destroy() {\n    this.singleDistExplorer.destroy(), this._touchMap = {}, this.nodeMap = {}, this.singleDistExplorer = void 0, this._opts = void 0, this.waitFnList = [], this.singleCountryNode = void 0;\n  }\n}\nfunction Ve(o) {\n  return [o.x, o.y];\n}\nclass qe {\n  constructor(t) {\n    this._data = [], this._pointsMap = {}, this._opts = v.extend({\n      topAdcode: 1e5\n    }, t), this.clearData();\n  }\n  clearData() {\n    this._data = [], this._pointsMap = {};\n  }\n  setData(t) {\n    this.clearData(), this._data = t, this._updatePointsMap(this._opts.topAdcode, \"all\", t);\n  }\n  _updatePointsMap(t, e, r) {\n    let i = this._pointsMap[t];\n    i || (i = this._pointsMap[t] = {}), i[e] = r, i[`${e}_pack`] = this._buildPackItemsByAdcode(t, r);\n  }\n  getPointsByAdcode(t, e) {\n    return this._pointsMap[t] ? this._pointsMap[t][e || \"all\"] : [];\n  }\n  getPackItemsByAdcode(t, e) {\n    return this._pointsMap[t] ? this._pointsMap[t][`${e || \"all\"}_pack`] : [];\n  }\n  _buildPackItemsByAdcode(t, e) {\n    const r = this._opts.pointPacker,\n      i = [];\n    for (let n = 0, s = e.length; n < s; n++) i[n] = r.call(this._opts.pointPackerThisArg, e[n]);\n    return i;\n  }\n  calcDistGroup(t, e, r, i) {\n    const n = this._opts.distMgr.getNodeByAdcode(t);\n    let s = n.acroutes || [1e5];\n    e && n.acroutes && (s = [].concat(s), s.push(t)), this._calcGroupWithRoutes(s, 0, r, i);\n  }\n  _calcGroupWithRoutes(t, e, r, i) {\n    const n = () => {\n        e < t.length - 1 ? this._calcGroupWithRoutes(t, e + 1, r, i) : r && r.call(i);\n      },\n      s = t[e];\n    if (this.getPointsByAdcode(s, \"__done\")) n.call(this);else {\n      const a = this.getPointsByAdcode(s);\n      if (!a) throw new Error(`Not points found:  ${s}`);\n      this._opts.distMgr.getExplorer().loadAreaNode(s, (u, l) => {\n        this._groupByAreaNode(l, a), n.call(this);\n      }, this, !0);\n    }\n  }\n  _groupByAreaNode(t, e) {\n    const r = t.groupByPosition(e, Ve),\n      i = t.getAdcode() === this._opts.topAdcode,\n      n = [];\n    for (let s = 0, a = r.length; s < a; s++) {\n      const u = r[s];\n      u.subFeature ? (this._updatePointsMap(u.subFeature.properties.adcode, \"all\", u.points), i && v.mergeArray(n, u.points)) : this._updatePointsMap(t.getAdcode(), \"hanging\", u.points);\n    }\n    i && this._updatePointsMap(t.getAdcode(), \"all\", n), this._updatePointsMap(t.getAdcode(), \"__done\", !0);\n  }\n  destroy() {\n    this.clearData(), this._opts = null;\n  }\n}\nvar je = Object.defineProperty,\n  Ue = Object.defineProperties,\n  We = Object.getOwnPropertyDescriptors,\n  Ft = Object.getOwnPropertySymbols,\n  Ye = Object.prototype.hasOwnProperty,\n  He = Object.prototype.propertyIsEnumerable,\n  Ot = (o, t, e) => t in o ? je(o, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : o[t] = e,\n  Ct = (o, t) => {\n    for (var e in t || (t = {})) Ye.call(t, e) && Ot(o, e, t[e]);\n    if (Ft) for (var e of Ft(t)) He.call(t, e) && Ot(o, e, t[e]);\n    return o;\n  },\n  Xe = (o, t) => Ue(o, We(t));\nclass Qe extends Y {\n  constructor(t, e) {\n    super(), this.baseId = 1, this._currentZoom = 2, this._currentFeatures = [], this._loadLeft = 0, this._polygonCache = [], this._markerCache = [], this._opts = v.extend({\n      engine: \"default\",\n      areaNodeCacheLimit: -1,\n      minHeightToShowSubFeatures: 630,\n      minSiblingAvgHeightToShowSubFeatures: 600,\n      minSubAvgHeightToShowSubFeatures: 300,\n      zooms: [2, 30],\n      clusterMarkerEventSupport: !0,\n      clusterMarkerClickToShowSub: !0,\n      featureEventSupport: !0,\n      featureClickToShowSub: !1,\n      featureStyleByLevel: {\n        country: {\n          strokeColor: \"rgb(31, 119, 180)\",\n          strokeOpacity: .9,\n          strokeWeight: 2,\n          fillColor: \"rgb(49, 163, 84)\",\n          fillOpacity: .8\n        },\n        province: {\n          strokeColor: \"rgb(31, 119, 180)\",\n          strokeOpacity: .9,\n          strokeWeight: 2,\n          fillColor: \"rgb(116, 196, 118)\",\n          fillOpacity: .7\n        },\n        city: {\n          strokeColor: \"rgb(31, 119, 180)\",\n          strokeOpacity: .9,\n          strokeWeight: 2,\n          fillColor: \"rgb(161, 217, 155)\",\n          fillOpacity: .6\n        },\n        district: {\n          strokeColor: \"rgb(31, 119, 180)\",\n          strokeOpacity: .9,\n          strokeWeight: 2,\n          fillColor: \"rgb(199, 233, 192)\",\n          fillOpacity: .5\n        }\n      }\n    }, e), this._map = this._opts.map, this._createLayer(), this._ins = t, this._isRendering = !1, this._loadLeft = 0, this._currentFeatures = [];\n  }\n  _createLayer() {\n    this.markerGroup = new AMap.OverlayGroup(), this._map.add(this.markerGroup), this.layer = new AMap.VectorLayer({\n      zIndex: this._opts.zIndex || 10,\n      visible: this._opts.visible || !0\n    }), this._map.addLayer(this.layer);\n  }\n  zoomToShowSubFeatures(t, e) {\n    const r = this.getMinZoomToShowSub(t);\n    if (r >= 3) {\n      const i = this._ins.getMap();\n      i && (e || (e = this._ins._distMgr.getNodeByAdcode(t).center), i.setZoomAndCenter(r, e));\n    }\n  }\n  getPixelRatio() {\n    return Math.min(2, Math.round(window.devicePixelRatio || 1));\n  }\n  refreshViewState() {\n    if (!this._ins._distMgr.isReady()) return !1;\n    const t = this._ins;\n    if (!t.isReady()) return !1;\n    const e = t.getMap(),\n      r = e.getBounds(),\n      i = e.getSize(),\n      n = e.getZoom(3),\n      s = this._opts.zooms[1],\n      a = Math.pow(2, s - n),\n      u = r.getNorthWest(),\n      l = e.lngLatToCoords([u.getLng(), u.getLat()]),\n      h = new C(l[0], l[1], i.width * a, i.height * a);\n    this._currentZoom = n, this._currentScaleFactor = a, this._currentViewBounds = h, this._currentViewBoundsInLngLat = r, this._currentPixelRatio = this.getPixelRatio();\n  }\n  renderViewport() {\n    if (this.refreshViewState(), !this._currentViewBounds) return !1;\n    this._currentRenderId = this.baseId++, this._loadLeft = 0, this._currentFeatures = [], this._renderViewDist(this._currentRenderId), this._isRendering = !1;\n  }\n  getCurrentRenderId() {\n    return this._currentRenderId;\n  }\n  isRenderIdStillValid(t) {\n    return t === this._currentRenderId;\n  }\n  _renderViewDist(t) {\n    const e = [];\n    if (this._currentZoom < this._opts.zooms[0] || this._currentZoom > this._opts.zooms[1]) {\n      this.isRenderIdStillValid(t) && this._prepareFeatures(t, e);\n      return;\n    }\n    this._ins.getDistMgr().traverseTopNodes(this._currentViewBoundsInLngLat, this._currentZoom, r => {\n      e.push(r.adcode);\n    }, () => {\n      this.isRenderIdStillValid(t) && this._prepareFeatures(t, e);\n    }, this);\n  }\n  getMinZoomToShowSub(t) {\n    const e = this._ins._distMgr.getNodeByAdcode(t);\n    if (!e || !e.idealZoom) return -1;\n    if (!e._minZoomToShowSub) {\n      const r = this._ins.getZooms();\n      for (let i = r[0]; i <= r[1]; i++) if (this.shouldShowSubOnZoom(e, i)) {\n        e._minZoomToShowSub = i;\n        break;\n      }\n    }\n    return e._minZoomToShowSub || -1;\n  }\n  shouldShowSubOnZoom(t, e) {\n    if (!t.idealZoom) return !1;\n    if (t._minZoomToShowSub && e >= t._minZoomToShowSub) return !0;\n    let r = this._ins._distMgr.getNodeBoundsSize(t, e);\n    if (t.adcode === 1e5 && r[1] > 400) return !0;\n    if (r[1] < this._opts.minHeightToShowSubFeatures) return !1;\n    let i, n, s;\n    if (t.children) {\n      const u = t.children;\n      if (s = 0, n = u.length, n) {\n        for (i = 0; i < n; i++) r = this._ins._distMgr.getNodeBoundsSize(u[i], e), s += r[1];\n        if (s / n < this._opts.minSubAvgHeightToShowSubFeatures) return !1;\n      }\n    }\n    const a = this._ins._distMgr.getParentAdcode(t.adcode, t.acroutes);\n    if (a) {\n      const u = this._ins._distMgr.getNodeByAdcode(a),\n        l = u.children;\n      if (l || console.error(\"No children bound\", t, u), n = l.length, n > 1) {\n        for (s = 0, i = 0; i < n; i++) l[i].adcode !== t.adcode && (r = this._ins._distMgr.getNodeBoundsSize(l[i], e), s += r[1]);\n        if (s / (n - 1) < this._opts.minSiblingAvgHeightToShowSubFeatures) return !1;\n      }\n    }\n    return !0;\n  }\n  _shouldShowSub(t) {\n    return !(!t.children || !t.children.length) && this.shouldShowSubOnZoom(t, this._currentZoom);\n  }\n  _prepareFeatures(t, e) {\n    const r = [],\n      i = [];\n    for (let n = 0, s = e.length; n < s; n++) {\n      const a = this._ins._distMgr.getNodeByAdcode(e[n]);\n      if (!a) throw new Error(`Can not find node: ${e[n]}`);\n      this._shouldShowSub(a) ? i.push(e[n]) : r.push(e[n]);\n    }\n    this._prepareSelfFeatures(t, r), this._prepareSubFeatures(t, i), this._checkLoadFinish(t);\n  }\n  _prepareSelfFeatures(t, e) {\n    let r;\n    const i = this._currentZoom;\n    for (let n = 0, s = e.length; n < s; n++) {\n      const a = this._ins._distMgr.getNodeByAdcode(e[n]);\n      if (r = null, a.acroutes) {\n        const u = this._ins._distMgr.getNodeByAdcode(a.acroutes[a.acroutes.length - 1]);\n        (!a.idealZoom || i < a.idealZoom - 1 || Math.abs(i - u.idealZoom) <= Math.abs(a.idealZoom - i)) && (r = u.adcode);\n      }\n      this._loadAndRenderSelf(t, r || e[n], e[n]);\n    }\n  }\n  _prepareSubFeatures(t, e) {\n    let r, i;\n    for (r = 0, i = e.length; r < i; r++) this._loadAndRenderSub(t, e[r]);\n  }\n  _renderSelf(t, e, r) {\n    let i;\n    if (e === r.getAdcode()) i = r.getParentFeature();else {\n      const n = r.getSubFeatures(),\n        s = this._ins._distMgr.getSubIdx(e);\n      if (i = n[s], !i) {\n        console.warn(\"Werid, can not find sub feature\", r.getAdcode(), e);\n        return;\n      }\n      if (i.properties.adcode !== e) {\n        console.warn(\"Sub adcode not match!!\", n, s);\n        return;\n      }\n    }\n    this._ins.getDistCounter().calcDistGroup(e, !1, () => {\n      this.isRenderIdStillValid(t) && this._prepRenderFeatureInPixel(t, i);\n    }, this);\n  }\n  _checkLoadFinish(t) {\n    if (this._loadLeft === 0) {\n      const e = this;\n      setTimeout(function () {\n        e.isRenderIdStillValid(t) && e._handleRenderFinish();\n      }, 0);\n    }\n  }\n  _renderSub(t, e) {\n    const r = e.getSubFeatures();\n    this._ins.getDistCounter().calcDistGroup(e.getAdcode(), !0, () => {\n      if (this.isRenderIdStillValid(t)) for (let i = 0, n = r.length; i < n; i++) this._prepRenderFeatureInPixel(t, r[i]);\n    }, this);\n  }\n  _handleRenderFinish() {\n    this._tryFreeMemery(), this._renderAllFeature();\n  }\n  _renderAllFeature() {\n    this._renderAllFeatureByDefault();\n  }\n  _renderAllFeatureByDefault() {\n    var t, e;\n    const r = [],\n      i = [],\n      n = [],\n      s = [];\n    for (let a = 0; a < this._polygonCache.length; a++) {\n      const u = this._polygonCache[a],\n        l = u.getExtData()._data.adcode;\n      let h = !1;\n      for (let c = 0; c < this._currentFeatures.length; c++) {\n        const d = this._currentFeatures[c].feature.properties;\n        if (l === d.adcode) {\n          h = !0, this._currentFeatures.splice(c, 1);\n          break;\n        }\n      }\n      h || (i.push(u), this._polygonCache.splice(a, 1), s.push(this._markerCache[a]), this._markerCache.splice(a, 1), a--);\n    }\n    this._currentFeatures.forEach(a => {\n      const u = this._createPolygonFeature(a.feature, a.dataItems);\n      this._opts.featureEventSupport && (u.on(\"click\", v.bind(h => {\n        this.emit(\"featureClick\", h, a.feature), this._opts.featureClickToShowSub && this._ins.zoomToShowSubFeatures(a.feature.properties.adcode);\n      }, this)), u.on(\"mouseover\", v.bind(h => {\n        this.emit(\"featureMouseover\", h, a.feature);\n      }, this)), u.on(\"mouseout\", v.bind(h => {\n        this.emit(\"featureMouseout\", h, a.feature);\n      }, this)));\n      const l = this._createClusterMarker(a.feature, a.dataItems);\n      this._opts.clusterMarkerEventSupport && l.on(\"click\", v.bind(h => {\n        this.emit(\"clusterMarkerClick\", h, Ct({\n          adcode: a.feature.properties.adcode\n        }, a)), this._opts.clusterMarkerEventSupport && this._ins.zoomToShowSubFeatures(a.feature.properties.adcode);\n      }, this)), r.push(u), n.push(l);\n    }), this.layer.remove(i), (t = this.markerGroup) === null || t === void 0 || t.removeOverlays(s), this.layer.add(r), this._polygonCache.push(...r), r.length = 0, (e = this.markerGroup) === null || e === void 0 || e.addOverlays(n), this._markerCache.push(...n), n.length = 0;\n  }\n  _tryFreeMemery() {\n    this._ins.getDistMgr().tryClearCache(this._currentRenderId, this._opts.areaNodeCacheLimit);\n  }\n  _increaseLoadLeft() {\n    this._loadLeft++;\n  }\n  _decreaseLoadLeft(t) {\n    this._loadLeft--, this._loadLeft === 0 && this._checkLoadFinish(t);\n  }\n  _loadAndRenderSelf(t, e, r) {\n    this._ins.getDistMgr().touchAdcode(e, t);\n    const i = this._ins._distMgr.getExplorer(),\n      n = i.getLocalAreaNode(e);\n    n ? this._renderSelf(t, r, n) : (this._increaseLoadLeft(), i.loadAreaNode(e, (s, a) => {\n      this.isRenderIdStillValid(t) && (s ? console.error(s) : this._renderSelf(t, r, a), this._decreaseLoadLeft(t));\n    }, this));\n  }\n  _loadAndRenderSub(t, e) {\n    this._ins.getDistMgr().touchAdcode(e, t);\n    const r = this._ins._distMgr.getExplorer(),\n      i = r.getLocalAreaNode(e);\n    i ? this._renderSub(t, i) : (this._increaseLoadLeft(), r.loadAreaNode(e, (n, s) => {\n      this.isRenderIdStillValid(t) && (n ? console.error(n) : this._renderSub(t, s), this._decreaseLoadLeft(t));\n    }, this));\n  }\n  _prepRenderFeatureInPixel(t, e) {\n    if (!this._ins.getDistMgr().isExcludedAdcode(e.properties.adcode)) {\n      const r = this._ins.getDistCounter().getPackItemsByAdcode(e.properties.adcode);\n      this._currentFeatures.push({\n        feature: e,\n        dataItems: r\n      });\n    }\n  }\n  _createPolygonFeature(t, e) {\n    const r = Object.assign({}, t.properties);\n    if (r.dataItems = e, this._opts.renderPolygon) {\n      const n = this._opts.renderPolygon(t, e),\n        s = n.getExtData() || {};\n      return s._data = r, n.setExtData(s), n;\n    }\n    const i = this._getFeatureStyleOptions(t, e) || {};\n    return new AMap.Polygon(Xe(Ct({\n      path: t.geometry.coordinates\n    }, i), {\n      extData: {\n        _data: r\n      }\n    }));\n  }\n  _createClusterMarker(t, e) {\n    const r = t.properties;\n    if (r.dataItems = e, this._opts.renderClusterMarker) {\n      const h = this._opts.renderClusterMarker(t, e),\n        c = h.getExtData() || {};\n      return c._data = r, h.setExtData(c), h;\n    }\n    const i = {\n        title: \"amap-ui-district-cluster-marker-title\",\n        body: \"amap-ui-district-cluster-marker-body\",\n        container: \"amap-ui-district-cluster-marker\"\n      },\n      n = document.createElement(\"div\"),\n      s = document.createElement(\"span\");\n    s.className = i.title;\n    const a = document.createElement(\"span\");\n    a.className = i.body, n.appendChild(s), n.appendChild(a);\n    const u = [],\n      l = [i.container, `level_${r.level}`, `adcode_${r.adcode}`];\n    if (r.acroutes) for (let h = r.acroutes, c = 0, d = h.length; c < d; c++) l.push(`descendant_of_${h[c]}`), c === d - 1 && l.push(`child_of_${h[c]}`), c > 0 && u.push(this._ins._distMgr.getNodeByAdcode(h[c]).name);\n    return n.className = l.join(\" \"), u.length > 0 ? (u.push(r.name), n.setAttribute(\"title\", u.join(\">\"))) : n.removeAttribute(\"title\"), s.innerHTML = v.escapeHtml(r.name), a.innerHTML = e.length, new AMap.Marker({\n      topWhenClick: !0,\n      offset: new AMap.Pixel(-20, -30),\n      content: n,\n      position: r.center,\n      extData: {\n        _data: r\n      }\n    });\n  }\n  _getFeatureStyleOptions(t, e) {\n    const r = this._opts.getFeatureStyle,\n      i = this._opts.featureStyleByLevel[t.properties.level];\n    if (!r) return i;\n    const n = r.call(null, t, e);\n    return n ? v.extend({}, this._opts.featureStyleByLevel[t.properties.level], n) : i;\n  }\n  renderLater(t) {\n    this._renderLaterId || (this._renderLaterId = setTimeout(() => {\n      this.render();\n    }, t || 100));\n  }\n  isRendering() {\n    return this._isRendering;\n  }\n  render() {\n    this._renderLaterId && (clearTimeout(this._renderLaterId), this._renderLaterId = null), this._isRendering = !0, this._ins._distMgr.onReady(this.renderViewport, this, !0);\n  }\n  getOption(t) {\n    return this._opts[t];\n  }\n  getOptions() {\n    return this._opts;\n  }\n  show() {\n    var t;\n    this.layer.show(), (t = this.markerGroup) === null || t === void 0 || t.show();\n  }\n  hide() {\n    var t;\n    this.layer.hide(), (t = this.markerGroup) === null || t === void 0 || t.hide();\n  }\n  clear() {\n    var t;\n    this.layer.clear(), (t = this.markerGroup) === null || t === void 0 || t.clearOverlays(), this._polygonCache = [], this._markerCache = [];\n  }\n  setzIndex(t) {\n    this.layer.setzIndex(t);\n  }\n  getZooms() {\n    return this._opts.zooms;\n  }\n  destroy() {\n    this._map.removeLayer(this.layer), this._map.remove(this.markerGroup), this._currentFeatures = [], this.clear(), this.layer = null, this._map = null, this._ins = null;\n  }\n}\nclass Je {\n  constructor(t, e, r) {\n    this.x = t, this.y = e, this.idx = r;\n  }\n}\nvar Ke = Object.defineProperty,\n  tr = Object.defineProperties,\n  er = Object.getOwnPropertyDescriptors,\n  Dt = Object.getOwnPropertySymbols,\n  rr = Object.prototype.hasOwnProperty,\n  ir = Object.prototype.propertyIsEnumerable,\n  Tt = (o, t, e) => t in o ? Ke(o, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: e\n  }) : o[t] = e,\n  nr = (o, t) => {\n    for (var e in t || (t = {})) rr.call(t, e) && Tt(o, e, t[e]);\n    if (Dt) for (var e of Dt(t)) ir.call(t, e) && Tt(o, e, t[e]);\n    return o;\n  },\n  or = (o, t) => tr(o, er(t));\nclass sr extends Y {\n  constructor(t) {\n    super(), this._data = {\n      list: [],\n      bounds: null,\n      source: null\n    }, this._mouseEvent = v.bind(v.debounce(() => {\n      this.renderLater();\n    }, 50), this);\n    const e = {\n      autoSetFitView: !0,\n      topAdcodes: [1e5],\n      visible: !0,\n      excludedAdcodes: null,\n      zIndex: 10,\n      renderOptions: {}\n    };\n    this._opts = v.extend({}, e, t), this.map = t.map, this._distMgr = new Ze({\n      topAdcodes: this._opts.topAdcodes,\n      excludedAdcodes: this._opts.excludedAdcodes\n    }), this._distCounter = new qe({\n      distMgr: this._distMgr,\n      pointPackerThisArg: this,\n      pointPacker: r => this._packDataItem(r)\n    }), this.renderEngine = new Qe(this, or(nr({}, t.renderOptions), {\n      zIndex: this._opts.zIndex,\n      visible: this._opts.visible,\n      map: t.map\n    })), this.renderEngine.on(\"*\", (r, ...i) => {\n      this.emit(r, ...i);\n    }), this._opts.data && this.setData(this._opts.data), this.bindOrUnbindMapEvent();\n  }\n  bindOrUnbindMapEvent(t = !0) {\n    const e = t ? \"on\" : \"off\";\n    this.map[e](\"moveend\", this._mouseEvent), this.map[e](\"zoomend\", this._mouseEvent), this.map[e](\"resize\", this._mouseEvent), this.map[e](\"rotateend\", this._mouseEvent), this.map[e](\"dragend\", this._mouseEvent);\n  }\n  getMinZoomToShowSub(t) {\n    return this.renderEngine.getMinZoomToShowSub(t);\n  }\n  getAreaNodeProps(t) {\n    return this._distMgr.getNodeByAdcode(t);\n  }\n  getDistrictExplorer() {\n    return this._distMgr.getExplorer();\n  }\n  getRender() {\n    return this.renderEngine;\n  }\n  zoomToShowSubFeatures(t, e) {\n    this.renderEngine.zoomToShowSubFeatures(t, e);\n  }\n  renderLater(t) {\n    this.renderEngine.renderLater(t);\n  }\n  render() {\n    this.renderEngine.render();\n  }\n  getDistMgr() {\n    return this._distMgr;\n  }\n  _clearData() {\n    this.trigger(\"willClearData\"), this._data ? this._data.list.length = 0 : this._data = {\n      list: [],\n      bounds: null\n    }, this._data.source = null, this._data.bounds = null, this._data.kdTree = null, this._distCounter.clearData(), this.trigger(\"didClearData\");\n  }\n  _buildDataItems(t) {\n    const e = this._opts,\n      r = e.getPosition,\n      i = this._data.list,\n      n = this._data.bounds;\n    for (let s = 0, a = t.length; s < a; s++) {\n      let u = t[s],\n        l = r.call(this, u, s);\n      l && (l.getLng && (l = [l.getLng(), l.getLat()]), i[s] = new Je(l[0], l[1], s), n.expandByPoint(l[0], l[1]));\n    }\n  }\n  getDataItemsByBounds(t) {\n    const e = this._data.kdTree;\n    if (!e) return null;\n    const r = t.getSouthWest(),\n      i = t.getNorthEast(),\n      n = this._data.list,\n      s = e.range(r.getLng(), r.getLat(), i.getLng(), i.getLat()),\n      a = [];\n    for (let u = 0, l = s.length; u < l; u++) a[u] = this._packDataItem(n[s[u]]);\n    return a;\n  }\n  _packDataItem(t) {\n    if (!t) return null;\n    if (!t._packedItem) {\n      const e = t.idx,\n        r = [t.x, t.y];\n      t._packedItem = {\n        dataIndex: e,\n        dataItem: this._data.source[e],\n        position: r\n      };\n    }\n    return t._packedItem;\n  }\n  _buildData(t) {\n    this._clearData(), this.trigger(\"willBuildData\", t), this._data.source = t, this._data.bounds = C.getBoundsItemToExpand(), this._buildDataItems(t), this._distCounter.setData(this._data.list), this.trigger(\"didBuildData\", t);\n  }\n  setData(t) {\n    t || (t = []), this._buildData(t), this.renderLater(10), t.length && this._opts.autoSetFitView && this.setFitView();\n  }\n  isReady() {\n    return this._distMgr.isReady() && !!this._data;\n  }\n  setFitView() {\n    const t = this._data.bounds,\n      e = this.getMap(),\n      r = new AMap.Bounds([t.x, t.y], [t.x + t.width, t.y + t.height]);\n    e && e.setBounds(r);\n  }\n  getDistCounter() {\n    return this._distCounter;\n  }\n  getMap() {\n    return this._opts.map;\n  }\n  getZooms() {\n    return this.renderEngine.getZooms();\n  }\n  isHidden() {\n    return !this._opts.visible;\n  }\n  show() {\n    return this._opts.visible = !0, this.getRender().show();\n  }\n  hide() {\n    return this._opts.visible = !1, this.getRender().hide();\n  }\n  destroy() {\n    this.bindOrUnbindMapEvent(!1), this.getRender().destroy(), this._distCounter.destroy(), this._distMgr.destroy(), this.renderEngine = null, this._data = {\n      list: [],\n      bounds: null\n    }, this._distMgr = null, this.map = void 0, this._opts = void 0;\n  }\n  getzIndex() {\n    return this._opts.zIndex;\n  }\n  setzIndex(t) {\n    this._opts.zIndex = t, this.getRender().setzIndex(t);\n  }\n}\n(function (o) {\n  const t = document,\n    e = \"appendChild\",\n    r = \"styleSheet\",\n    i = t.createElement(\"style\");\n  i.type = \"text/css\", t.getElementsByTagName(\"head\")[0][e](i), i[r] ? i[r].cssText = o : i[e](t.createTextNode(o));\n})(\".amap-ui-district-cluster-container{cursor:default;-webkit-backface-visibility:hidden;-webkit-transform:translateZ(0) scale(1,1)}.amap-ui-district-cluster-container canvas{position:absolute}.amap-ui-district-cluster-container .amap-ui-hide{display:none!important}.amap-ui-district-cluster-container .overlay-title,.amap-ui-district-cluster-marker{color:#555;background-color:#fffeef;font-size:12px;white-space:nowrap;position:absolute}.amap-ui-district-cluster-container .overlay-title{padding:2px 6px;display:inline-block;z-index:99999;border:1px solid #7e7e7e;border-radius:2px}.amap-ui-district-cluster-container .overlay-title:after,.amap-ui-district-cluster-container .overlay-title:before{content:'';display:block;position:absolute;margin:auto;width:0;height:0;border:solid transparent;border-width:5px}.amap-ui-district-cluster-container .overlay-title.left{transform:translate(10px,-50%)}.amap-ui-district-cluster-container .overlay-title.left:before{top:5px}.amap-ui-district-cluster-container .overlay-title.left:after{left:-9px;top:5px;border-right-color:#fffeef}.amap-ui-district-cluster-container .overlay-title.left:before{left:-10px;border-right-color:#7e7e7e}.amap-ui-district-cluster-container .overlay-title.top{transform:translate(-50%,-130%)}.amap-ui-district-cluster-container .overlay-title.top:before{left:0;right:0}.amap-ui-district-cluster-container .overlay-title.top:after{bottom:-9px;left:0;right:0;border-top-color:#fffeef}.amap-ui-district-cluster-container .overlay-title.top:before{bottom:-10px;border-top-color:#7e7e7e}.amap-ui-district-cluster-marker{border:1px solid #8e8e8e;width:auto;height:22px;border-radius:5px 5px 5px 0;left:0;top:0}.amap-ui-district-cluster-marker:after,.amap-ui-district-cluster-marker:before{content:'';display:block;position:absolute;width:0;height:0;border:solid rgba(0,0,0,0);border-width:6px;left:13px}.amap-ui-district-cluster-marker:after{bottom:-12px;border-top-color:#fffeef}.amap-ui-district-cluster-marker:before{bottom:-13px;border-top-color:#8e8e8e}.amap-ui-district-cluster-marker span{vertical-align:middle;padding:3px 5px;display:inline-block;height:16px;line-height:16px}.amap-ui-district-cluster-marker-title{border-radius:5px 0 0 0}.amap-ui-district-cluster-marker-body{background-color:#dc3912;color:#fff;border-radius:0 5px 5px 0}.amap-ui-district-cluster-marker.level_country .amap-ui-district-cluster-marker-body{background-color:#36c}.amap-ui-district-cluster-marker.level_province .amap-ui-district-cluster-marker-body{background-color:#dc3912}.amap-ui-district-cluster-marker.level_city .amap-ui-district-cluster-marker-body{background-color:#909}.amap-ui-district-cluster-marker.level_district .amap-ui-district-cluster-marker-body{background-color:#d47}\");\nexport { sr as DistrictCluster };","map":{"version":3,"names":["Y","constructor","n","_listeners","on","t","e","r","push","callback","isOnce","off","Error","length","i","splice","emit","s","call","trigger","dt","o","type","id","bbox","properties","geometry","H","a","coordinates","Bt","ft","$t","label","sent","trys","ops","next","throw","return","Symbol","iterator","l","h","u","TypeError","done","value","pop","A","key","data","left","right","zt","P","X","pt","Gt","Q","J","_root","_size","_comparator","prototype","insert","add","remove","_remove","findStatic","find","contains","forEach","range","keys","values","min","minNode","max","maxNode","at","prev","clear","toList","Vt","load","et","K","qt","Zt","tt","head","isEmpty","Object","defineProperty","get","enumerable","configurable","toString","String","join","update","split","Math","floor","S","gt","writable","b","z","ll","x","ur","y","rt","N","Number","EPSILON","pow","jt","it","Ut","reset","xRounder","yt","yRounder","round","tree","G","Z","vt","_t","V","sqrt","Wt","Yt","mt","xt","Ht","c","d","f","g","I","comparePoints","point","link","isLeft","q","compare","segment","events","checkForConsuming","consumedBy","otherSE","consume","ringOut","isInResult","Map","set","sine","cosine","has","Xt","leftSE","rightSE","comparePoint","p","m","w","_","k","rings","windings","isAnEndpoint","vector","replaceRightSE","slice","swapEvents","indexOf","_prevInResult","prevInResult","_beforeState","multiPolys","afterState","_afterState","beforeState","poly","isExterior","multiPoly","_isInResult","L","numMultiPolys","abs","isSubject","concat","bt","Array","isArray","segments","fromRing","Qt","exteriorRing","interiorRings","getSweepEvents","wt","polys","POSITIVE_INFINITY","NEGATIVE_INFINITY","Jt","getAvailableLinkedEvents","index","unshift","reverse","getLeftmostComparator","sort","shift","isExteriorRing","_isExteriorRing","enclosingRing","_enclosingRing","_calcEnclosingRing","St","getGeom","Kt","_composePolys","addInterior","te","arguments","queue","getIntersection","_splitSafely","D","M","R","E","T","F","U","B","$","W","Et","process","env","POLYGON_CLIPPING_MAX_QUEUE_SIZE","ee","POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS","re","size","factory","ie","run","ne","oe","se","ae","union","intersection","xor","difference","ue","v","mergeArray","apply","now","Date","getTime","bind","map","merge","arrayIndexOf","extend","extendObjs","hasOwnProperty","debounce","setTimeout","throttle","leading","clearTimeout","trailing","escapeHtml","replace","nt","BBRFLAG","ADCODES","COUNTRY","le","he","scale","translate","ce","de","objects","features","geometries","Lt","fe","transform","arcs","pe","ot","kt","ge","ye","ve","_e","me","xe","MAX_VALUE","j","sqClosestDistanceToPolygon","pointOnPolygon","pointInPolygon","polygonClip","st","be","parseInt","It","we","Se","Ee","At","Le","ke","idx","idxList","mxr","maxRect","mxsr","maxSubRect","Ie","geoData","sub","console","warn","Ae","bbIndex","Pt","prepareGridFeatureClip","buildIdxList","C","width","height","getBoundsItemToExpand","boundsIntersect","expandByPoint","Pe","Ne","parent","acroutes","adcode","subFeatureIndex","Me","_isBuiled","topo","bounds","Re","buildData","ut","O","PI","Nt","Fe","Mt","lt","Oe","log","tan","Ce","De","atan","exp","parseFloat","toFixed","Te","Rt","Be","$e","ze","cos","asin","ht","haversineDistance","getScale","lngLatToPointByScale","pointToLngLat","lngLatToPoint","ct","_data","_sqScaleFactor","_opts","assign","nearTolerance","setNearTolerance","getPropsOfFeature","getAdcodeOfFeature","doesFeatureHasChildren","childrenNum","_sqNearTolerance","getIdealZoom","idealZoom","_getEmptySubFeatureGroupItem","subFeature","getSubFeatureByIndex","pointsIndexes","points","groupByPosition","getLocatedSubFeatureIndex","_getLocatedSubFeatureIndexByPixel","lngLatToPixel","getSubFeatures","_calcLocatedFeatureIndexOfSList","_calcNearestFeatureIndexOfSList","sq","pixelToLngLat","pz","AMap","LngLat","getLng","getLat","_convertRingCoordsToLngLats","_convertPolygonCoordsToLngLats","_convertMultiPolygonCoordsToLngLats","_convertCoordsToLngLats","_createLngLatFeature","getAdcode","getProps","getName","getChildrenNum","getParentFeature","lngLatParent","getParentFeatureInPixel","lngLatSubList","getSubFeaturesInPixel","getBounds","lngLatBounds","Bounds","Ge","distDataLoc","_areaNodesForLocating","_areaNodeCache","preload","loadMultiAreaNodes","setAreaNodesForLocating","_loadJson","fetch","headers","Accept","then","json","catch","_getAreaNodeDataFileName","_getAreaNodeDataSrc","loadAreaTree","loadCountryNode","loadAreaNode","_buildAreaNode","getLocalAreaNode","clearAreaNodeCacheByAdcode","destroy","Ze","isDistReady","nodeMap","waitFnList","singleDistExplorer","topAdcodes","_touchMap","filterAreaTree","singleCountryNode","bbounds","children","childIdx","isReady","getParentAdcode","getNodeByAdcode","getSubIdx","getChildrenNumOfNode","substr","getNodeChildren","getExplorer","traverseCountry","traverseNode","getNodeBoundsSize","getPixelZoom","doesRingRingIntersect","getNorthWest","toArray","getNorthEast","getSouthEast","getSouthWest","count","total","onReady","isExcludedAdcode","excludedAdcodes","traverseTopNodes","tryClearCache","touchAdcode","Ve","qe","_pointsMap","topAdcode","clearData","setData","_updatePointsMap","_buildPackItemsByAdcode","getPointsByAdcode","getPackItemsByAdcode","pointPacker","pointPackerThisArg","calcDistGroup","distMgr","_calcGroupWithRoutes","_groupByAreaNode","je","Ue","defineProperties","We","getOwnPropertyDescriptors","Ft","getOwnPropertySymbols","Ye","He","propertyIsEnumerable","Ot","Ct","Xe","Qe","baseId","_currentZoom","_currentFeatures","_loadLeft","_polygonCache","_markerCache","engine","areaNodeCacheLimit","minHeightToShowSubFeatures","minSiblingAvgHeightToShowSubFeatures","minSubAvgHeightToShowSubFeatures","zooms","clusterMarkerEventSupport","clusterMarkerClickToShowSub","featureEventSupport","featureClickToShowSub","featureStyleByLevel","country","strokeColor","strokeOpacity","strokeWeight","fillColor","fillOpacity","province","city","district","_map","_createLayer","_ins","_isRendering","markerGroup","OverlayGroup","layer","VectorLayer","zIndex","visible","addLayer","zoomToShowSubFeatures","getMinZoomToShowSub","getMap","_distMgr","center","setZoomAndCenter","getPixelRatio","window","devicePixelRatio","refreshViewState","getSize","getZoom","lngLatToCoords","_currentScaleFactor","_currentViewBounds","_currentViewBoundsInLngLat","_currentPixelRatio","renderViewport","_currentRenderId","_renderViewDist","getCurrentRenderId","isRenderIdStillValid","_prepareFeatures","getDistMgr","_minZoomToShowSub","getZooms","shouldShowSubOnZoom","error","_shouldShowSub","_prepareSelfFeatures","_prepareSubFeatures","_checkLoadFinish","_loadAndRenderSelf","_loadAndRenderSub","_renderSelf","getDistCounter","_prepRenderFeatureInPixel","_handleRenderFinish","_renderSub","_tryFreeMemery","_renderAllFeature","_renderAllFeatureByDefault","getExtData","feature","_createPolygonFeature","dataItems","_createClusterMarker","removeOverlays","addOverlays","_increaseLoadLeft","_decreaseLoadLeft","renderPolygon","setExtData","_getFeatureStyleOptions","Polygon","path","extData","renderClusterMarker","title","body","container","document","createElement","className","appendChild","level","name","setAttribute","removeAttribute","innerHTML","Marker","topWhenClick","offset","Pixel","content","position","getFeatureStyle","renderLater","_renderLaterId","render","isRendering","getOption","getOptions","show","hide","clearOverlays","setzIndex","removeLayer","Je","Ke","tr","er","Dt","rr","ir","Tt","nr","or","sr","list","source","_mouseEvent","autoSetFitView","renderOptions","_distCounter","_packDataItem","renderEngine","bindOrUnbindMapEvent","getAreaNodeProps","getDistrictExplorer","getRender","_clearData","kdTree","_buildDataItems","getPosition","getDataItemsByBounds","_packedItem","dataIndex","dataItem","_buildData","setFitView","setBounds","isHidden","getzIndex","getElementsByTagName","cssText","createTextNode","DistrictCluster"],"sources":["../src/packages/event/index.ts","../node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js","../node_modules/.pnpm/@turf+invariant@6.5.0/node_modules/@turf/invariant/dist/es/index.js","../node_modules/.pnpm/splaytree@3.1.1/node_modules/splaytree/dist/splay.esm.js","../node_modules/.pnpm/polygon-clipping@0.15.3/node_modules/polygon-clipping/dist/polygon-clipping.esm.js","../node_modules/.pnpm/@turf+intersect@6.5.0/node_modules/@turf/intersect/dist/es/index.js","../src/packages/layer/utils.js","../src/packages/layer/Const.ts","../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/identity.js","../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/transform.js","../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/reverse.js","../node_modules/.pnpm/topojson-client@3.1.0/node_modules/topojson-client/src/feature.js","../src/packages/layer/geomUtils.ts","../src/packages/layer/bbIdxBuilder.ts","../src/packages/layer/BoundsItem.ts","../src/packages/layer/distDataParser.ts","../src/packages/layer/SphericalMercator.ts","../src/packages/layer/AreaNode.ts","../src/packages/layer/DistrictExplorer.ts","../src/packages/layer/DistMgr.ts","../src/packages/layer/DistCounter.ts","../src/packages/layer/BaseRender.ts","../src/packages/layer/PointItem.ts","../src/packages/layer/index.ts"],"sourcesContent":[null,"/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","/**\n * splaytree v3.1.1\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? ' ' : ' ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var n;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    n = this.minNode();\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!n) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, n];\r\n                case 2:\r\n                    _a.sent();\r\n                    n = this.next(n);\r\n                    return [3 /*break*/, 1];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\nexport default Tree;\n//# sourceMappingURL=splay.esm.js.map\n","import SplayTree from 'splaytree';\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\nvar isInBbox = function isInBbox(bbox, point) {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\n\nvar getBboxOverlap = function getBboxOverlap(b1, b2) {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\nvar epsilon = Number.EPSILON; // IE Polyfill\n\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nvar EPSILON_SQ = epsilon * epsilon;\n/* FLP comparator */\n\nvar cmp = function cmp(a, b) {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  } // check if they're flp equal\n\n\n  var ab = a - b;\n\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  } // normal comparison\n\n\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nvar PtRounder = /*#__PURE__*/function () {\n  function PtRounder() {\n    _classCallCheck(this, PtRounder);\n\n    this.reset();\n  }\n\n  _createClass(PtRounder, [{\n    key: \"reset\",\n    value: function reset() {\n      this.xRounder = new CoordRounder();\n      this.yRounder = new CoordRounder();\n    }\n  }, {\n    key: \"round\",\n    value: function round(x, y) {\n      return {\n        x: this.xRounder.round(x),\n        y: this.yRounder.round(y)\n      };\n    }\n  }]);\n\n  return PtRounder;\n}();\n\nvar CoordRounder = /*#__PURE__*/function () {\n  function CoordRounder() {\n    _classCallCheck(this, CoordRounder);\n\n    this.tree = new SplayTree(); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n    this.round(0);\n  } // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n\n\n  _createClass(CoordRounder, [{\n    key: \"round\",\n    value: function round(coord) {\n      var node = this.tree.add(coord);\n      var prevNode = this.tree.prev(node);\n\n      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n        this.tree.remove(coord);\n        return prevNode.key;\n      }\n\n      var nextNode = this.tree.next(node);\n\n      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n        this.tree.remove(coord);\n        return nextNode.key;\n      }\n\n      return coord;\n    }\n  }]);\n\n  return CoordRounder;\n}(); // singleton available by import\n\n\nvar rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\n\nvar crossProduct = function crossProduct(a, b) {\n  return a.x * b.y - a.y * b.x;\n};\n/* Dot Product of two vectors with first point at origin */\n\nvar dotProduct = function dotProduct(a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n/* Comparator for two vectors with same starting point */\n\nvar compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n  var v1 = {\n    x: endPt1.x - basePt.x,\n    y: endPt1.y - basePt.y\n  };\n  var v2 = {\n    x: endPt2.x - basePt.x,\n    y: endPt2.y - basePt.y\n  };\n  var kross = crossProduct(v1, v2);\n  return cmp(kross, 0);\n};\nvar length = function length(v) {\n  return Math.sqrt(dotProduct(v, v));\n};\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar horizontalIntersection = function horizontalIntersection(pt, v, y) {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar verticalIntersection = function verticalIntersection(pt, v, x) {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar intersection = function intersection(pt1, v1, pt2, v2) {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  var kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  var ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  var d1 = crossProduct(ve, v1) / kross;\n  var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n  var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n  var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n  var x = (x1 + x2) / 2;\n  var y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar SweepEvent = /*#__PURE__*/function () {\n  _createClass(SweepEvent, null, [{\n    key: \"compare\",\n    // for ordering sweep events in the sweep event queue\n    value: function compare(a, b) {\n      // favor event with a point that the sweep line hits first\n      var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n      if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n      if (a.point !== b.point) a.link(b); // favor right events over left\n\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n      // ordering of this case is the same as for their segments\n\n      return Segment.compare(a.segment, b.segment);\n    } // for ordering points in sweep line order\n\n  }, {\n    key: \"comparePoints\",\n    value: function comparePoints(aPt, bPt) {\n      if (aPt.x < bPt.x) return -1;\n      if (aPt.x > bPt.x) return 1;\n      if (aPt.y < bPt.y) return -1;\n      if (aPt.y > bPt.y) return 1;\n      return 0;\n    } // Warning: 'point' input will be modified and re-used (for performance)\n\n  }]);\n\n  function SweepEvent(point, isLeft) {\n    _classCallCheck(this, SweepEvent);\n\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n  }\n\n  _createClass(SweepEvent, [{\n    key: \"link\",\n    value: function link(other) {\n      if (other.point === this.point) {\n        throw new Error('Tried to link already linked events');\n      }\n\n      var otherEvents = other.point.events;\n\n      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        var evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n      }\n\n      this.checkForConsuming();\n    }\n    /* Do a pass over our linked events and check to see if any pair\n     * of segments match, and should be consumed. */\n\n  }, {\n    key: \"checkForConsuming\",\n    value: function checkForConsuming() {\n      // FIXME: The loops in this method run O(n^2) => no good.\n      //        Maintain little ordered sweep event trees?\n      //        Can we maintaining an ordering that avoids the need\n      //        for the re-sorting with getLeftmostComparator in geom-out?\n      // Compare each pair of events to see if other events also match\n      var numEvents = this.point.events.length;\n\n      for (var i = 0; i < numEvents; i++) {\n        var evt1 = this.point.events[i];\n        if (evt1.segment.consumedBy !== undefined) continue;\n\n        for (var j = i + 1; j < numEvents; j++) {\n          var evt2 = this.point.events[j];\n          if (evt2.consumedBy !== undefined) continue;\n          if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n          evt1.segment.consume(evt2.segment);\n        }\n      }\n    }\n  }, {\n    key: \"getAvailableLinkedEvents\",\n    value: function getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      var events = [];\n\n      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        var evt = this.point.events[i];\n\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n\n  }, {\n    key: \"getLeftmostComparator\",\n    value: function getLeftmostComparator(baseEvent) {\n      var _this = this;\n\n      var cache = new Map();\n\n      var fillCache = function fillCache(linkedEvent) {\n        var nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n\n      return function (a, b) {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n\n        var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n\n        var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n        if (asine >= 0 && bsine >= 0) {\n          if (acosine < bcosine) return 1;\n          if (acosine > bcosine) return -1;\n          return 0;\n        } // both below x-axis\n\n\n        if (asine < 0 && bsine < 0) {\n          if (acosine < bcosine) return -1;\n          if (acosine > bcosine) return 1;\n          return 0;\n        } // one above x-axis, one below\n\n\n        if (bsine < asine) return -1;\n        if (bsine > asine) return 1;\n        return 0;\n      };\n    }\n  }]);\n\n  return SweepEvent;\n}();\n\n// segments and sweep events when all else is identical\n\nvar segmentId = 0;\n\nvar Segment = /*#__PURE__*/function () {\n  _createClass(Segment, null, [{\n    key: \"compare\",\n\n    /* This compare() function is for ordering segments in the sweep\n     * line tree, and does so according to the following criteria:\n     *\n     * Consider the vertical line that lies an infinestimal step to the\n     * right of the right-more of the two left endpoints of the input\n     * segments. Imagine slowly moving a point up from negative infinity\n     * in the increasing y direction. Which of the two segments will that\n     * point intersect first? That segment comes 'before' the other one.\n     *\n     * If neither segment would be intersected by such a line, (if one\n     * or more of the segments are vertical) then the line to be considered\n     * is directly on the right-more of the two left inputs.\n     */\n    value: function compare(a, b) {\n      var alx = a.leftSE.point.x;\n      var blx = b.leftSE.point.x;\n      var arx = a.rightSE.point.x;\n      var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n      if (brx < alx) return 1;\n      if (arx < blx) return -1;\n      var aly = a.leftSE.point.y;\n      var bly = b.leftSE.point.y;\n      var ary = a.rightSE.point.y;\n      var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n      if (alx < blx) {\n        // are the two segments in the same horizontal plane?\n        if (bly < aly && bly < ary) return 1;\n        if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n        var aCmpBLeft = a.comparePoint(b.leftSE.point);\n        if (aCmpBLeft < 0) return 1;\n        if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n        var bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return -1;\n      } // is left endpoint of segment A the right-more?\n\n\n      if (alx > blx) {\n        if (aly < bly && aly < bry) return -1;\n        if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n        var bCmpALeft = b.comparePoint(a.leftSE.point);\n        if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n        var aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return 1;\n      } // if we get here, the two left endpoints are in the same\n      // vertical plane, ie alx === blx\n      // consider the lower left-endpoint to come first\n\n\n      if (aly < bly) return -1;\n      if (aly > bly) return 1; // left endpoints are identical\n      // check for colinearity by using the left-more right endpoint\n      // is the A right endpoint more left-more?\n\n      if (arx < brx) {\n        var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n        if (_bCmpARight !== 0) return _bCmpARight;\n      } // is the B right endpoint more left-more?\n\n\n      if (arx > brx) {\n        var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n        if (_aCmpBRight < 0) return 1;\n        if (_aCmpBRight > 0) return -1;\n      }\n\n      if (arx !== brx) {\n        // are these two [almost] vertical segments with opposite orientation?\n        // if so, the one with the lower right endpoint comes first\n        var ay = ary - aly;\n        var ax = arx - alx;\n        var by = bry - bly;\n        var bx = brx - blx;\n        if (ay > ax && by < bx) return 1;\n        if (ay < ax && by > bx) return -1;\n      } // we have colinear segments with matching orientation\n      // consider the one with more left-more right endpoint to be first\n\n\n      if (arx > brx) return 1;\n      if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n      // vertical plane, ie arx === brx\n      // consider the lower right-endpoint to come first\n\n      if (ary < bry) return -1;\n      if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n      // fall back on creation order as consistent tie-breaker\n\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1; // identical segment, ie a === b\n\n      return 0;\n    }\n    /* Warning: a reference to ringWindings input will be stored,\n     *  and possibly will be later modified */\n\n  }]);\n\n  function Segment(leftSE, rightSE, rings, windings) {\n    _classCallCheck(this, Segment);\n\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings; // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  _createClass(Segment, [{\n    key: \"replaceRightSE\",\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    value: function replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var y1 = this.leftSE.point.y;\n      var y2 = this.rightSE.point.y;\n      return {\n        ll: {\n          x: this.leftSE.point.x,\n          y: y1 < y2 ? y1 : y2\n        },\n        ur: {\n          x: this.rightSE.point.x,\n          y: y1 > y2 ? y1 : y2\n        }\n      };\n    }\n    /* A vector from the left point to the right */\n\n  }, {\n    key: \"vector\",\n    value: function vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n  }, {\n    key: \"isAnEndpoint\",\n    value: function isAnEndpoint(pt) {\n      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n    /* Compare this segment with a point.\n     *\n     * A point P is considered to be colinear to a segment if there\n     * exists a distance D such that if we travel along the segment\n     * from one * endpoint towards the other a distance D, we find\n     * ourselves at point P.\n     *\n     * Return value indicates:\n     *\n     *   1: point lies above the segment (to the left of vertical)\n     *   0: point is colinear to segment\n     *  -1: point lies below the segment (to the right of vertical)\n     */\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      var lPt = this.leftSE.point;\n      var rPt = this.rightSE.point;\n      var v = this.vector(); // Exactly vertical segments.\n\n      if (lPt.x === rPt.x) {\n        if (point.x === lPt.x) return 0;\n        return point.x < lPt.x ? 1 : -1;\n      } // Nearly vertical segments with an intersection.\n      // Check to see where a point on the line with matching Y coordinate is.\n\n\n      var yDist = (point.y - lPt.y) / v.y;\n      var xFromYDist = lPt.x + yDist * v.x;\n      if (point.x === xFromYDist) return 0; // General case.\n      // Check to see where a point on the line with matching X coordinate is.\n\n      var xDist = (point.x - lPt.x) / v.x;\n      var yFromXDist = lPt.y + xDist * v.y;\n      if (point.y === yFromXDist) return 0;\n      return point.y < yFromXDist ? -1 : 1;\n    }\n    /**\n     * Given another segment, returns the first non-trivial intersection\n     * between the two segments (in terms of sweep line ordering), if it exists.\n     *\n     * A 'non-trivial' intersection is one that will cause one or both of the\n     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n     *\n     *   * endpoint of segA with endpoint of segB --> trivial\n     *   * endpoint of segA with point along segB --> non-trivial\n     *   * endpoint of segB with point along segA --> non-trivial\n     *   * point along segA with point along segB --> non-trivial\n     *\n     * If no non-trivial intersection exists, return null\n     * Else, return null.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      var tBbox = this.bbox();\n      var oBbox = other.bbox();\n      var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n      if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n      // This will 'snap' intersections to endpoints if possible, and will\n      // handle cases of colinearity.\n\n      var tlp = this.leftSE.point;\n      var trp = this.rightSE.point;\n      var olp = other.leftSE.point;\n      var orp = other.rightSE.point; // does each endpoint touch the other segment?\n      // note that we restrict the 'touching' definition to only allow segments\n      // to touch endpoints that lie forward from where we are in the sweep line pass\n\n      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n      if (touchesThisLSE && touchesOtherLSE) {\n        // these two cases are for colinear segments with matching left\n        // endpoints, and one segment being longer than the other\n        if (touchesThisRSE && !touchesOtherRSE) return trp;\n        if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n        // or just on their left endpoint (one trivial intersection\n\n        return null;\n      } // does this left endpoint matches (other doesn't)\n\n\n      if (touchesThisLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesOtherRSE) {\n          if (tlp.x === orp.x && tlp.y === orp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return tlp;\n      } // does other left endpoint matches (this doesn't)\n\n\n      if (touchesOtherLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesThisRSE) {\n          if (trp.x === olp.x && trp.y === olp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return olp;\n      } // trivial intersection on right endpoints\n\n\n      if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n      if (touchesThisRSE) return trp;\n      if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n      // infinite lines laid over the segments\n\n      var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n      // they would have an endpoint intersection and that case was already handled above\n\n      if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n      if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n      return rounder.round(pt.x, pt.y);\n    }\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(point) {\n      var newEvents = [];\n      var alreadyLinked = point.events !== undefined;\n      var newLeftSE = new SweepEvent(point, true);\n      var newRightSE = new SweepEvent(point, false);\n      var oldRightSE = this.rightSE;\n      this.replaceRightSE(newRightSE);\n      newEvents.push(newRightSE);\n      newEvents.push(newLeftSE);\n      var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n      // sometimes one of the resulting new segments is vertical, in which\n      // case its left and right events may need to be swapped\n\n      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n        newSeg.swapEvents();\n      }\n\n      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n        this.swapEvents();\n      } // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n\n\n      if (alreadyLinked) {\n        newLeftSE.checkForConsuming();\n        newRightSE.checkForConsuming();\n      }\n\n      return newEvents;\n    }\n    /* Swap which event is left and right */\n\n  }, {\n    key: \"swapEvents\",\n    value: function swapEvents() {\n      var tmpEvt = this.rightSE;\n      this.rightSE = this.leftSE;\n      this.leftSE = tmpEvt;\n      this.leftSE.isLeft = true;\n      this.rightSE.isLeft = false;\n\n      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n        this.windings[i] *= -1;\n      }\n    }\n    /* Consume another segment. We take their rings under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n\n  }, {\n    key: \"consume\",\n    value: function consume(other) {\n      var consumer = this;\n      var consumee = other;\n\n      while (consumer.consumedBy) {\n        consumer = consumer.consumedBy;\n      }\n\n      while (consumee.consumedBy) {\n        consumee = consumee.consumedBy;\n      }\n\n      var cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n\n      if (cmp > 0) {\n        var tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      } // make sure a segment doesn't consume it's prev\n\n\n      if (consumer.prev === consumee) {\n        var _tmp = consumer;\n        consumer = consumee;\n        consumee = _tmp;\n      }\n\n      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n        var ring = consumee.rings[i];\n        var winding = consumee.windings[i];\n        var index = consumer.rings.indexOf(ring);\n\n        if (index === -1) {\n          consumer.rings.push(ring);\n          consumer.windings.push(winding);\n        } else consumer.windings[index] += winding;\n      }\n\n      consumee.rings = null;\n      consumee.windings = null;\n      consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n    /* The first segment previous segment chain that is in the result */\n\n  }, {\n    key: \"prevInResult\",\n    value: function prevInResult() {\n      if (this._prevInResult !== undefined) return this._prevInResult;\n      if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n      return this._prevInResult;\n    }\n  }, {\n    key: \"beforeState\",\n    value: function beforeState() {\n      if (this._beforeState !== undefined) return this._beforeState;\n      if (!this.prev) this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };else {\n        var seg = this.prev.consumedBy || this.prev;\n        this._beforeState = seg.afterState();\n      }\n      return this._beforeState;\n    }\n  }, {\n    key: \"afterState\",\n    value: function afterState() {\n      if (this._afterState !== undefined) return this._afterState;\n      var beforeState = this.beforeState();\n      this._afterState = {\n        rings: beforeState.rings.slice(0),\n        windings: beforeState.windings.slice(0),\n        multiPolys: []\n      };\n      var ringsAfter = this._afterState.rings;\n      var windingsAfter = this._afterState.windings;\n      var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n        var ring = this.rings[i];\n        var winding = this.windings[i];\n        var index = ringsAfter.indexOf(ring);\n\n        if (index === -1) {\n          ringsAfter.push(ring);\n          windingsAfter.push(winding);\n        } else windingsAfter[index] += winding;\n      } // calcualte polysAfter\n\n\n      var polysAfter = [];\n      var polysExclude = [];\n\n      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n        if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n        var _ring = ringsAfter[_i];\n        var poly = _ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (_ring.isExterior) polysAfter.push(poly);else {\n          if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n          var _index = polysAfter.indexOf(_ring.poly);\n\n          if (_index !== -1) polysAfter.splice(_index, 1);\n        }\n      } // calculate multiPolysAfter\n\n\n      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n        var mp = polysAfter[_i2].multiPoly;\n        if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n      }\n\n      return this._afterState;\n    }\n    /* Is this segment part of the final result? */\n\n  }, {\n    key: \"isInResult\",\n    value: function isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n      if (this._isInResult !== undefined) return this._isInResult;\n      var mpsBefore = this.beforeState().multiPolys;\n      var mpsAfter = this.afterState().multiPolys;\n\n      switch (operation.type) {\n        case 'union':\n          {\n            // UNION - included iff:\n            //  * On one side of us there is 0 poly interiors AND\n            //  * On the other side there is 1 or more.\n            var noBefores = mpsBefore.length === 0;\n            var noAfters = mpsAfter.length === 0;\n            this._isInResult = noBefores !== noAfters;\n            break;\n          }\n\n        case 'intersection':\n          {\n            // INTERSECTION - included iff:\n            //  * on one side of us all multipolys are rep. with poly interiors AND\n            //  * on the other side of us, not all multipolys are repsented\n            //    with poly interiors\n            var least;\n            var most;\n\n            if (mpsBefore.length < mpsAfter.length) {\n              least = mpsBefore.length;\n              most = mpsAfter.length;\n            } else {\n              least = mpsAfter.length;\n              most = mpsBefore.length;\n            }\n\n            this._isInResult = most === operation.numMultiPolys && least < most;\n            break;\n          }\n\n        case 'xor':\n          {\n            // XOR - included iff:\n            //  * the difference between the number of multipolys represented\n            //    with poly interiors on our two sides is an odd number\n            var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n            this._isInResult = diff % 2 === 1;\n            break;\n          }\n\n        case 'difference':\n          {\n            // DIFFERENCE included iff:\n            //  * on exactly one side, we have just the subject\n            var isJustSubject = function isJustSubject(mps) {\n              return mps.length === 1 && mps[0].isSubject;\n            };\n\n            this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n            break;\n          }\n\n        default:\n          throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n      }\n\n      return this._isInResult;\n    }\n  }], [{\n    key: \"fromRing\",\n    value: function fromRing(pt1, pt2, ring) {\n      var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n      var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n      if (cmpPts < 0) {\n        leftPt = pt1;\n        rightPt = pt2;\n        winding = 1;\n      } else if (cmpPts > 0) {\n        leftPt = pt2;\n        rightPt = pt1;\n        winding = -1;\n      } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n      var leftSE = new SweepEvent(leftPt, true);\n      var rightSE = new SweepEvent(rightPt, false);\n      return new Segment(leftSE, rightSE, [ring], [winding]);\n    }\n  }]);\n\n  return Segment;\n}();\n\nvar RingIn = /*#__PURE__*/function () {\n  function RingIn(geomRing, poly, isExterior) {\n    _classCallCheck(this, RingIn);\n\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n\n    if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    var prevPoint = firstPoint;\n\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    } // add segment from last to first if last is not the same as first\n\n\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n\n  _createClass(RingIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n        var segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return RingIn;\n}();\nvar PolyIn = /*#__PURE__*/function () {\n  function PolyIn(geomPoly, multiPoly) {\n    _classCallCheck(this, PolyIn);\n\n    if (!Array.isArray(geomPoly)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      var ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n\n    this.multiPoly = multiPoly;\n  }\n\n  _createClass(PolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = this.exteriorRing.getSweepEvents();\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return PolyIn;\n}();\nvar MultiPolyIn = /*#__PURE__*/function () {\n  function MultiPolyIn(geom, isSubject) {\n    _classCallCheck(this, MultiPolyIn);\n\n    if (!Array.isArray(geom)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === 'number') geom = [geom];\n    } catch (ex) {// The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n\n    for (var i = 0, iMax = geom.length; i < iMax; i++) {\n      var poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n\n    this.isSubject = isSubject;\n  }\n\n  _createClass(MultiPolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polySweepEvents = this.polys[i].getSweepEvents();\n\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return MultiPolyIn;\n}();\n\nvar RingOut = /*#__PURE__*/function () {\n  _createClass(RingOut, null, [{\n    key: \"factory\",\n\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    value: function factory(allSegments) {\n      var ringsOut = [];\n\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n        var segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n        var prevEvent = null;\n        var event = segment.leftSE;\n        var nextEvent = segment.rightSE;\n        var events = [event];\n        var startingPoint = event.point;\n        var intersectionLEs = [];\n        /* Walk the chain of linked events to form a closed ring */\n\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n          /* Is the ring complete? */\n\n          if (event.point === startingPoint) break;\n\n          while (true) {\n            var availableLEs = event.getAvailableLinkedEvents();\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n             * part of the algorithm malfunctioned... please file a bug report. */\n\n            if (availableLEs.length === 0) {\n              var firstPt = events[0].point;\n              var lastPt = events[events.length - 1].point;\n              throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n            }\n            /* Only one way to go, so cotinue on the path */\n\n\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n            /* We must have an intersection. Check for a completed loop */\n\n\n            var indexLE = null;\n\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n\n\n            if (indexLE !== null) {\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\n              var ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n\n\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n\n            var comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n\n        ringsOut.push(new RingOut(events));\n      }\n\n      return ringsOut;\n    }\n  }]);\n\n  function RingOut(events) {\n    _classCallCheck(this, RingOut);\n\n    this.events = events;\n\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n\n    this.poly = null;\n  }\n\n  _createClass(RingOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      var prevPt = this.events[0].point;\n      var points = [prevPt];\n\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        var _pt = this.events[i].point;\n        var _nextPt = this.events[i + 1].point;\n        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n        points.push(_pt);\n        prevPt = _pt;\n      } // ring was all (within rounding error of angle calc) colinear points\n\n\n      if (points.length === 1) return null; // check if the starting point is necessary\n\n      var pt = points[0];\n      var nextPt = points[1];\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n      points.push(points[0]);\n      var step = this.isExteriorRing() ? 1 : -1;\n      var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      var iEnd = this.isExteriorRing() ? points.length : -1;\n      var orderedPoints = [];\n\n      for (var _i = iStart; _i != iEnd; _i += step) {\n        orderedPoints.push([points[_i].x, points[_i].y]);\n      }\n\n      return orderedPoints;\n    }\n  }, {\n    key: \"isExteriorRing\",\n    value: function isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        var enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n\n      return this._isExteriorRing;\n    }\n  }, {\n    key: \"enclosingRing\",\n    value: function enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n\n      return this._enclosingRing;\n    }\n    /* Returns the ring that encloses this one, if any */\n\n  }, {\n    key: \"_calcEnclosingRing\",\n    value: function _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      var leftMostEvt = this.events[0];\n\n      for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n        var evt = this.events[i];\n        if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n\n      var prevSeg = leftMostEvt.segment.prevInResult();\n      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n\n        if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        } // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n\n\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }]);\n\n  return RingOut;\n}();\nvar PolyOut = /*#__PURE__*/function () {\n  function PolyOut(exteriorRing) {\n    _classCallCheck(this, PolyOut);\n\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n\n  _createClass(PolyOut, [{\n    key: \"addInterior\",\n    value: function addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n  }, {\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n      if (geom[0] === null) return null;\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n\n      return geom;\n    }\n  }]);\n\n  return PolyOut;\n}();\nvar MultiPolyOut = /*#__PURE__*/function () {\n  function MultiPolyOut(rings) {\n    _classCallCheck(this, MultiPolyOut);\n\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n\n  _createClass(MultiPolyOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n\n      return geom;\n    }\n  }, {\n    key: \"_composePolys\",\n    value: function _composePolys(rings) {\n      var polys = [];\n\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\n        var ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          var enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n\n      return polys;\n    }\n  }]);\n\n  return MultiPolyOut;\n}();\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nvar SweepLine = /*#__PURE__*/function () {\n  function SweepLine(queue) {\n    var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n    _classCallCheck(this, SweepLine);\n\n    this.queue = queue;\n    this.tree = new SplayTree(comparator);\n    this.segments = [];\n  }\n\n  _createClass(SweepLine, [{\n    key: \"process\",\n    value: function process(event) {\n      var segment = event.segment;\n      var newEvents = []; // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n\n      if (event.consumedBy) {\n        if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n        return newEvents;\n      }\n\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n      if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n      var prevNode = node;\n      var nextNode = node;\n      var prevSeg = undefined;\n      var nextSeg = undefined; // skip consumed segments still in tree\n\n      while (prevSeg === undefined) {\n        prevNode = this.tree.prev(prevNode);\n        if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n      } // skip consumed segments still in tree\n\n\n      while (nextSeg === undefined) {\n        nextNode = this.tree.next(nextNode);\n        if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n      }\n\n      if (event.isLeft) {\n        // Check for intersections against the previous segment in the sweep line\n        var prevMySplitter = null;\n\n        if (prevSeg) {\n          var prevInter = prevSeg.getIntersection(segment);\n\n          if (prevInter !== null) {\n            if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n            if (!prevSeg.isAnEndpoint(prevInter)) {\n              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        } // Check for intersections against the next segment in the sweep line\n\n\n        var nextMySplitter = null;\n\n        if (nextSeg) {\n          var nextInter = nextSeg.getIntersection(segment);\n\n          if (nextInter !== null) {\n            if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n            if (!nextSeg.isAnEndpoint(nextInter)) {\n              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                newEvents.push(_newEventsFromSplit[_i]);\n              }\n            }\n          }\n        } // For simplicity, even if we find more than one intersection we only\n        // spilt on the 'earliest' (sweep-line style) of the intersections.\n        // The other intersection will be handled in a future process().\n\n\n        if (prevMySplitter !== null || nextMySplitter !== null) {\n          var mySplitter = null;\n          if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n          } // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n\n          var _newEventsFromSplit2 = segment.split(mySplitter);\n\n          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n            newEvents.push(_newEventsFromSplit2[_i2]);\n          }\n        }\n\n        if (newEvents.length > 0) {\n          // We found some intersections, so re-do the current event to\n          // make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers\n          this.tree.remove(segment);\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          var inter = prevSeg.getIntersection(nextSeg);\n\n          if (inter !== null) {\n            if (!prevSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                newEvents.push(_newEventsFromSplit3[_i3]);\n              }\n            }\n\n            if (!nextSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                newEvents.push(_newEventsFromSplit4[_i4]);\n              }\n            }\n          }\n        }\n\n        this.tree.remove(segment);\n      }\n\n      return newEvents;\n    }\n    /* Safely split a segment that is currently in the datastructures\n     * IE - a segment other than the one that is currently being processed. */\n\n  }, {\n    key: \"_splitSafely\",\n    value: function _splitSafely(seg, pt) {\n      // Rounding errors can cause changes in ordering,\n      // so remove afected segments and right sweep events before splitting\n      // removeNode() doesn't work, so have re-find the seg\n      // https://github.com/w8r/splay-tree/pull/5\n      this.tree.remove(seg);\n      var rightSE = seg.rightSE;\n      this.queue.remove(rightSE);\n      var newEvents = seg.split(pt);\n      newEvents.push(rightSE); // splitting can trigger consumption\n\n      if (seg.consumedBy === undefined) this.tree.insert(seg);\n      return newEvents;\n    }\n  }]);\n\n  return SweepLine;\n}();\n\nvar POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nvar POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nvar Operation = /*#__PURE__*/function () {\n  function Operation() {\n    _classCallCheck(this, Operation);\n  }\n\n  _createClass(Operation, [{\n    key: \"run\",\n    value: function run(type, geom, moreGeoms) {\n      operation.type = type;\n      rounder.reset();\n      /* Convert inputs to MultiPoly objects */\n\n      var multipolys = [new MultiPolyIn(geom, true)];\n\n      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n      }\n\n      operation.numMultiPolys = multipolys.length;\n      /* BBox optimization for difference operation\n       * If the bbox of a multipolygon that's part of the clipping doesn't\n       * intersect the bbox of the subject at all, we can just drop that\n       * multiploygon. */\n\n      if (operation.type === 'difference') {\n        // in place removal\n        var subject = multipolys[0];\n        var _i = 1;\n\n        while (_i < multipolys.length) {\n          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n        }\n      }\n      /* BBox optimization for intersection operation\n       * If we can find any pair of multipolygons whose bbox does not overlap,\n       * then the result will be empty. */\n\n\n      if (operation.type === 'intersection') {\n        // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n        //       it could be optimized to O(n * ln(n))\n        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n          var mpA = multipolys[_i2];\n\n          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n          }\n        }\n      }\n      /* Put segment endpoints in a priority queue */\n\n\n      var queue = new SplayTree(SweepEvent.compare);\n\n      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n        var sweepEvents = multipolys[_i3].getSweepEvents();\n\n        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n          queue.insert(sweepEvents[_j]);\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n          }\n        }\n      }\n      /* Pass the sweep line over those endpoints */\n\n\n      var sweepLine = new SweepLine(queue);\n      var prevQueueSize = queue.size;\n      var node = queue.pop();\n\n      while (node) {\n        var evt = node.key;\n\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          var seg = evt.segment;\n          throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n        }\n\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n        }\n\n        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n        }\n\n        var newEvents = sweepLine.process(evt);\n\n        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n          var _evt = newEvents[_i4];\n          if (_evt.consumedBy === undefined) queue.insert(_evt);\n        }\n\n        prevQueueSize = queue.size;\n        node = queue.pop();\n      } // free some memory we don't need anymore\n\n\n      rounder.reset();\n      /* Collect and compile segments we're keeping into a multipolygon */\n\n      var ringsOut = RingOut.factory(sweepLine.segments);\n      var result = new MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }]);\n\n  return Operation;\n}(); // singleton available by import\n\nvar operation = new Operation();\n\nvar union = function union(geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n\n  return operation.run('union', geom, moreGeoms);\n};\n\nvar intersection$1 = function intersection(geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n\n  return operation.run('intersection', geom, moreGeoms);\n};\n\nvar xor = function xor(geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n\n  return operation.run('xor', geom, moreGeoms);\n};\n\nvar difference = function difference(subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n\n  return operation.run('difference', subjectGeom, clippingGeoms);\n};\n\nvar index = {\n  union: union,\n  intersection: intersection$1,\n  xor: xor,\n  difference: difference\n};\n\nexport default index;\n","import { multiPolygon, polygon, } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\nimport polygonClipping from \"polygon-clipping\";\n/**\n * Takes two {@link Polygon|polygon} or {@link MultiPolygon|multi-polygon} geometries and\n * finds their polygonal intersection. If they don't intersect, returns null.\n *\n * @name intersect\n * @param {Feature<Polygon | MultiPolygon>} poly1 the first polygon or multipolygon\n * @param {Feature<Polygon | MultiPolygon>} poly2 the second polygon or multipolygon\n * @param {Object} [options={}] Optional Parameters\n * @param {Object} [options.properties={}] Translate GeoJSON Properties to Feature\n * @returns {Feature|null} returns a feature representing the area they share (either a {@link Polygon} or\n * {@link MultiPolygon}). If they do not share any area, returns `null`.\n * @example\n * var poly1 = turf.polygon([[\n *   [-122.801742, 45.48565],\n *   [-122.801742, 45.60491],\n *   [-122.584762, 45.60491],\n *   [-122.584762, 45.48565],\n *   [-122.801742, 45.48565]\n * ]]);\n *\n * var poly2 = turf.polygon([[\n *   [-122.520217, 45.535693],\n *   [-122.64038, 45.553967],\n *   [-122.720031, 45.526554],\n *   [-122.669906, 45.507309],\n *   [-122.723464, 45.446643],\n *   [-122.532577, 45.408574],\n *   [-122.487258, 45.477466],\n *   [-122.520217, 45.535693]\n * ]]);\n *\n * var intersection = turf.intersect(poly1, poly2);\n *\n * //addToMap\n * var addToMap = [poly1, poly2, intersection];\n */\nexport default function intersect(poly1, poly2, options) {\n    if (options === void 0) { options = {}; }\n    var geom1 = getGeom(poly1);\n    var geom2 = getGeom(poly2);\n    var intersection = polygonClipping.intersection(geom1.coordinates, geom2.coordinates);\n    if (intersection.length === 0)\n        return null;\n    if (intersection.length === 1)\n        return polygon(intersection[0], options.properties);\n    return multiPolygon(intersection, options.properties);\n}\n","const utils = {\r\n  mergeArray(target, source) {\r\n    if (source.length < 5e4) target.push.apply(target, source)\r\n    else for (let i = 0, len = source.length; i < len; i += 1) target.push(source[i])\r\n  },\r\n  now:\r\n    Date.now ||\r\n    function () {\r\n      return new Date().getTime()\r\n    },\r\n  bind(fn, thisArg) {\r\n    return fn.bind\r\n      ? fn.bind(thisArg)\r\n      : function () {\r\n          return fn.apply(thisArg, arguments)\r\n        }\r\n  },\r\n  forEach(array, callback, thisArg) {\r\n    if (array.forEach) return array.forEach(callback, thisArg)\r\n    for (let i = 0, len = array.length; i < len; i++) callback.call(thisArg, array[i], i)\r\n  },\r\n  map(array, callback, thisArg) {\r\n    if (array.map) return array.map(callback, thisArg)\r\n    const newArr = []\r\n    for (let i = 0, len = array.length; i < len; i++) newArr[i] = callback.call(thisArg, array[i], i)\r\n    return newArr\r\n  },\r\n  merge(array1, array2) {\r\n    if (array2.length < 5e4) Array.prototype.push.apply(array1, array2)\r\n    else for (let ii = 0, iilen = array2.length; ii < iilen; ii += 1) array1.push(array2[ii])\r\n  },\r\n  arrayIndexOf(array, searchElement, fromIndex) {\r\n    if (array.indexOf) return array.indexOf(searchElement, fromIndex)\r\n    let k,\r\n      o = array,\r\n      len = o.length >>> 0\r\n    if (0 === len) return -1\r\n    const n = 0 | fromIndex\r\n    if (n >= len) return -1\r\n    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0)\r\n    for (; k < len; ) {\r\n      if (k in o && o[k] === searchElement) return k\r\n      k++\r\n    }\r\n    return -1\r\n  },\r\n  extend(dst) {\r\n    dst || (dst = {})\r\n    return this.extendObjs(dst, Array.prototype.slice.call(arguments, 1))\r\n  },\r\n  extendObjs(dst, objs) {\r\n    dst || (dst = {})\r\n    for (let i = 0, len = objs.length; i < len; i++) {\r\n      const source = objs[i]\r\n      if (source) for (const prop in source) source.hasOwnProperty(prop) && (dst[prop] = source[prop])\r\n    }\r\n    return dst\r\n  },\r\n  debounce(func, wait, immediate) {\r\n    let timeout,\r\n      args,\r\n      context,\r\n      timestamp,\r\n      result,\r\n      later = function () {\r\n        const last = utils.now() - timestamp\r\n        if (last < wait && last >= 0) timeout = setTimeout(later, wait - last)\r\n        else {\r\n          timeout = null\r\n          if (!immediate) {\r\n            result = func.apply(context, args)\r\n            timeout || (context = args = null)\r\n          }\r\n        }\r\n      }\r\n    return function () {\r\n      context = this\r\n      args = arguments\r\n      timestamp = utils.now()\r\n      const callNow = immediate && !timeout\r\n      timeout || (timeout = setTimeout(later, wait))\r\n      if (callNow) {\r\n        result = func.apply(context, args)\r\n        context = args = null\r\n      }\r\n      return result\r\n    }\r\n  },\r\n  throttle(func, wait, options) {\r\n    let context,\r\n      args,\r\n      result,\r\n      timeout = null,\r\n      previous = 0\r\n    options || (options = {})\r\n    const later = function () {\r\n      previous = options.leading === !1 ? 0 : utils.now()\r\n      timeout = null\r\n      result = func.apply(context, args)\r\n      timeout || (context = args = null)\r\n    }\r\n    return function () {\r\n      const now = utils.now()\r\n      previous || options.leading !== !1 || (previous = now)\r\n      const remaining = wait - (now - previous)\r\n      context = this\r\n      args = arguments\r\n      if (remaining <= 0 || remaining > wait) {\r\n        if (timeout) {\r\n          clearTimeout(timeout)\r\n          timeout = null\r\n        }\r\n        previous = now\r\n        result = func.apply(context, args)\r\n        timeout || (context = args = null)\r\n      } else timeout || options.trailing === !1 || (timeout = setTimeout(later, remaining))\r\n      return result\r\n    }\r\n  },\r\n  escapeHtml(text) {\r\n    const map = {\r\n      '&': '&amp;',\r\n      '<': '&lt;',\r\n      '>': '&gt;',\r\n      '\"': '&quot;',\r\n      \"'\": '&#x27;',\r\n      '`': '&#x60;'\r\n    }\r\n    return `${text}`.replace(/[&<>\"']/g, function (m) {\r\n      return map[m]\r\n    })\r\n  }\r\n}\r\nexport { utils as default }\r\n",null,"export default function(x) {\n  return x;\n}\n","import identity from \"./identity.js\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","import reverse from \"./reverse.js\";\nimport transform from \"./transform.js\";\n\nexport default function(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nfunction feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n",null,null,null,null,null,null,null,null,null,null,null,null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}